<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World!</title>
    <url>/posts/1c291ca3.html</url>
    <content><![CDATA[<p>世界，你好！</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>MIT-Missing-Semester笔记(一):Shell</title>
    <url>/posts/f350bbc1.html</url>
    <content><![CDATA[<p>MIT的课程：<a href="https://missing.csail.mit.edu/2020/">Missing Semester</a></p>
<p>介绍了Shell、vim、git等一些常用工具</p>
<p>检查Shell语法错误的在线网站<a href="https://www.shellcheck.net/">ShellCheck</a></p>
<h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>一开始介绍了一些常用的命令，大部分之前使用过。</p>
<p>重定向符号<code>&lt;</code>、<code>&gt;</code>，追加用<code>&gt;&gt;</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello</span><br><span class="line"><span class="built_in">cd</span> - <span class="comment">#回到上一个目录</span></span><br><span class="line"><span class="built_in">cat</span> 2.txt &gt;&gt; 1.txt</span><br><span class="line"><span class="built_in">ls</span> -l | <span class="built_in">tail</span> -n3 <span class="comment">#输出最后三行</span></span><br><span class="line">man <span class="built_in">ls</span> <span class="comment">#多用man</span></span><br><span class="line"><span class="built_in">ls</span> -<span class="built_in">ls</span> <span class="comment">#-l显示详细信息，-s显示文件占用块数block，后面可跟上目录</span></span><br><span class="line">4 -rwxrw-r-- 1 hsl hsl  132 12月  3 20:26 <span class="built_in">test</span></span><br><span class="line"><span class="comment">#文件占用块数、-文件d目录l链接</span></span><br><span class="line"><span class="comment">#权限：rwx读写执行权限，分别是拥有者、用户组、其他人</span></span><br><span class="line"><span class="comment">#文件数量、拥有者、用户组、时间、文件名</span></span><br><span class="line"><span class="built_in">chmod</span> u+x <span class="built_in">test</span></span><br><span class="line">curl --<span class="built_in">head</span> --silent google.com | grep --ignore-case content-length | <span class="built_in">cut</span> --delimiter=<span class="string">&#x27; &#x27;</span> -f2</span><br></pre></td></tr></table></figure>
<p>\转义字符，<code>mkdir my\ photo</code>将空格转义，否则会建立两个目录</p>
<p>touch命令本意是修改时间戳，-a修改访问时间，-m改变修改时间，文件不存在时会默认新建</p>
<p>.sh文件开头<code>#!/bin/sh</code>是shebang，指示解释器运行环境</p>
<p>/sys目录下有很多系统设置，一切皆文件！</p>
<p>tee命令读取标准输入，写到标准输出和文件</p>
<p>还讲了find、grep、curl、cut命令，后面再看一下</p>
<h3 id="变量、函数"><a href="#变量、函数" class="headerlink" title="变量、函数"></a>变量、函数</h3><p>变量定义: <code>foo=bar</code>, 等号左右不能有空格，否则相当于调用foo命令，=和bar作参数。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">foo=bar <span class="comment">#单引号、双引号不同</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$foo</span>&quot;</span></span><br><span class="line"><span class="comment"># prints bar</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$foo&#x27;</span></span><br><span class="line"><span class="comment"># prints $foo</span></span><br></pre></td></tr></table></figure>
<p>写一个mcd命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> mcd.sh</span><br><span class="line"><span class="function"><span class="title">mcd</span></span> () &#123;</span><br><span class="line">	<span class="built_in">mkdir</span> -p <span class="variable">$1</span></span><br><span class="line">	<span class="built_in">cd</span> <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">source</span> mcd.sh</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$0</code> - Name of the script</li>
<li><code>$1</code> to <code>$9</code> - Arguments to the script. <code>$1</code> is the first argument and so on.</li>
<li><code>$@</code> - All the arguments</li>
<li><code>$#</code> - Number of arguments</li>
<li><code>$?</code> - Return code of the previous command</li>
<li>$$$$ - Process identification number (PID) for the current script</li>
<li><code>!!</code> - Entire last command, including arguments. A common pattern is to execute a command only for it to fail due to missing permissions; you can quickly re-execute the command with sudo by doing <code>sudo !!</code></li>
<li><code>$_</code> - Last argument from the last command. If you are in an interactive shell, you can also quickly get this value by typing <code>Esc</code> followed by <code>.</code> or <code>Alt+.</code></li>
</ul>
<p>详细见：<a href="https://missing.csail.mit.edu/2020/shell-tools/">https://missing.csail.mit.edu/2020/shell-tools/</a></p>
<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p><strong>command substitution</strong></p>
<p><code>for file in $(ls)</code></p>
<p><strong>process substitution</strong></p>
<p><code>diff &lt;(ls foo) &lt;(ls bar)</code>, &lt;( CMD ) 将执行 CMD 并将输出放在一个临时文件中，并将 &lt;() 替换为该文件的名称。</p>
<h3 id="脚本举例"><a href="#脚本举例" class="headerlink" title="脚本举例"></a>脚本举例</h3><p>举例（<strong>比较时尽量使用双方括号</strong>, <a href="http://mywiki.wooledge.org/BashFAQ/031">why</a>）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Starting program at <span class="subst">$(date)</span>&quot;</span> <span class="comment"># Date will be substituted</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Running program <span class="variable">$0</span> with <span class="variable">$#</span> arguments with pid $$&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    grep foobar <span class="string">&quot;<span class="variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null</span><br><span class="line">    <span class="comment"># When pattern is not found, grep has exit status 1</span></span><br><span class="line">    <span class="comment"># We redirect STDOUT and STDERR to a null register since we do not care about them</span></span><br><span class="line">    <span class="keyword">if</span> [[ $? -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;File <span class="variable">$file</span> does not have any foobar, adding one&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;# foobar&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<ul>
<li>正则表达式</li>
</ul>
<p>? 匹配一个任意字符，* 匹配多个，{} 匹配花括号里所有</p>
<p>一个python脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="built_in">reversed</span>(sys.argv[<span class="number">1</span>:]):</span><br><span class="line">    <span class="built_in">print</span>(arg)</span><br></pre></td></tr></table></figure>
<p>shebang写成这样移植性更好</p>
<h3 id="函数和脚本"><a href="#函数和脚本" class="headerlink" title="函数和脚本"></a>函数和脚本</h3><ul>
<li>函数（平时一般叫命令？）必须和shell用同样的语言，脚本可以用任何语言，所以shebang很重要。</li>
<li>函数在读取其定义时加载一次。每次执行脚本时都会加载脚本。这使得函数的加载速度稍快一些，但是无论何时更改它们，都必须重新加载它们的定义。source命令吧</li>
<li>函数在当前的 shell 环境中执行，而脚本在它们自己的进程中执行。因此，函数可以修改环境变量，例如更改当前目录，而脚本不能。后面再看下export命令</li>
</ul>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Find all directories named src</span></span><br><span class="line">find . -name src -<span class="built_in">type</span> d</span><br><span class="line"><span class="comment"># *匹配0个或多个目录，在文件那匹配0个或多个字符，？只能匹配一个</span></span><br><span class="line">find . -path <span class="string">&#x27;*/test/*.py&#x27;</span> -<span class="built_in">type</span> f</span><br><span class="line"><span class="comment"># Find all files modified in the last day</span></span><br><span class="line">find . -mtime -1</span><br><span class="line"><span class="comment"># Find all zip files with size in range 500k to 10M</span></span><br><span class="line">find . -size +500k -size -10M -name <span class="string">&#x27;*.tar.gz&#x27;</span></span><br><span class="line"><span class="comment"># Find all python files where I used the requests library</span></span><br><span class="line">rg -t py <span class="string">&#x27;import requests&#x27;</span></span><br><span class="line"><span class="comment"># Find all files (including hidden files) without a shebang line</span></span><br><span class="line">rg -u --files-without-match <span class="string">&quot;^#!&quot;</span></span><br><span class="line"><span class="comment"># Find all matches of foo and print the following 5 lines</span></span><br><span class="line">rg foo -A 5</span><br><span class="line"><span class="comment"># Print statistics of matches (# of matched lines and files )</span></span><br><span class="line">rg --stats PATTERN</span><br><span class="line"><span class="comment"># -R递归搜索目录，-n显示行号，-C显示邻近几行</span></span><br><span class="line">grep -R -n -C 5 foobar .</span><br></pre></td></tr></table></figure>
<p>其他类似grep的搜索工具 <a href="https://github.com/beyondgrep/ack3">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a>和<a href="https://github.com/BurntSushi/ripgrep">rg</a>, 模糊匹配的<a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a>. 还有两个终端文件管理工具，<a href="https://github.com/jarun/nnn"><code>nnn</code></a> 和 <a href="https://github.com/ranger/ranger"><code>ranger</code></a>，看着挺炫酷，后面试一试</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://tldr.sh/">tldr</a>工具</p>
</li>
<li><p>一些命令不能从管道中读取数据，xargs可以将标准输入转化为参数。<code>ls | xargs rm</code></p>
</li>
</ul>
<h3 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h3><ol>
<li><p><code>ls -lath --color=auto</code>, -a显示隐藏文件，-t按修改时间降序排列，-h大小显示为多少M，多少k的形式。</p>
</li>
<li><p>执行marco时记录下当前目录，执行polo时回到之前记录的目录。</p>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">marco</span></span>() &#123;</span><br><span class="line">	<span class="built_in">export</span> MARCO=$(<span class="built_in">pwd</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">polo</span></span>() &#123;</span><br><span class="line">	<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$MARCO</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>运行err.sh脚本, 记录其输出和错误日志, 输出其出错时的运行次数</li>
</ol>
<p>err.sh</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"> n=$(( RANDOM % <span class="number">100</span> ))</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> [[ n -eq 42 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Something went wrong at <span class="subst">$(date)</span>&quot;</span></span><br><span class="line">    <span class="comment"># &gt;2是将输出重定向到文件2, &amp;2才是标准错误</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The error was using magic numbers&quot;</span> 1&gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Everything went according to plan&quot;</span></span><br></pre></td></tr></table></figure>
<p>errTest.sh</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">rm</span> record.txt record2.txt</span><br><span class="line">t=1</span><br><span class="line">./err.sh &gt; ./record.txt 2&gt; ./record2.txt</span><br><span class="line"><span class="keyword">while</span> [[ $? -eq 0 ]]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">let</span> t++</span><br><span class="line">	./err.sh &gt;&gt; ./record.txt 2&gt;&gt; ./record2.txt</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">cat</span> record.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;------&quot;</span></span><br><span class="line"><span class="built_in">cat</span> record2.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;run counts: <span class="variable">$t</span>&quot;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>搜索当前文件下的html文件并打包压缩，搜索出来的内容以换行符区分 ( 排除文件名中包含空格的情况 ) .</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xargs -d 指定分隔符</span></span><br><span class="line">find -name <span class="string">&quot;*.html&quot;</span> | xargs -d <span class="string">&#x27;\n&#x27;</span> tar -czvf archieve.tar.gz</span><br></pre></td></tr></table></figure>
<ol>
<li>递归搜索当前文件夹中的文件，按文件最后修改时间逆序排列</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># stat -c或--format格式化输出 Y是UNIX时间戳，y是可读时间，n文件名</span></span><br><span class="line"><span class="comment"># sort -n按数值比较 -r逆序</span></span><br><span class="line"><span class="comment"># cut -d分隔符 -f, --fields显示什么字段，从1开始，2-取第二个及以后</span></span><br><span class="line"><span class="comment"># head列出前几行，默认10</span></span><br><span class="line">find . -<span class="built_in">type</span> f | xargs -d <span class="string">&#x27;\n&#x27;</span> <span class="built_in">stat</span> --format <span class="string">&quot;%Y %y %n&quot;</span> | <span class="built_in">sort</span> -nr | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 2- | <span class="built_in">head</span> -n 5</span><br><span class="line">2022-12-28 20:46:34.869589528 +0800 ./22/33/1 3.html</span><br><span class="line">2022-12-28 20:46:00.144839386 +0800 ./22/2 .html</span><br><span class="line">2022-12-28 20:45:30.952572281 +0800 ./1.html</span><br><span class="line">2022-12-27 23:13:16.676754571 +0800 ./record.txt</span><br><span class="line">2022-12-27 23:13:16.676754571 +0800 ./record2.txt</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL笔记</title>
    <url>/posts/fd5f561d.html</url>
    <content><![CDATA[<p>MySQL学习过程中的一些知识点<span id="more"></span></p>
<ol>
<li>全部使用长连接，内存占用问题</li>
</ol>
<blockquote>
<p>1.定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后， 断开连接，之后要查询再重连。</p>
<p>2.如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执 行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权 限验证，但是会将连接恢复到刚刚创建完时的状态。</p>
</blockquote>
<ol>
<li>为什么不建议使用查询缓存</li>
</ol>
<blockquote>
<p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清 空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新 压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很 长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p>
</blockquote>
<ol>
<li><p>Write-Ahead Logging: 先写日志，再写磁盘</p>
</li>
<li><p>redolog只是完成了prepare, 而binlog又失败，那么事务本身会回滚</p>
</li>
</ol>
<blockquote>
<p>1 prepare阶段 2 写binlog 3 commit </p>
<p>当在2之前崩溃时 重启恢复：后发现没有commit，回滚。备份恢复：没有binlog 。 一致 </p>
<p>当在3之前崩溃 重启恢复：虽没有commit，但满足prepare和binlog完整，所以重启后会自动commit。备份：有binlog. 一致</p>
</blockquote>
<ol>
<li>一天一备份、一周一备份</li>
</ol>
<blockquote>
<p>RTO（恢复目标时间）好处是“最长恢复时间”更短。 在一天一备的模式里，最坏情况下需要应用一天的 binlog。当然这个是有成本的，因为更频繁全量备份需要消耗更多存储空间，所以这个 RTO 是成 本换来的，就需要你根据业务重要性来评估了。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm总结</title>
    <url>/posts/d6085898.html</url>
    <content><![CDATA[<p>jvm学习中的一些知识点<span id="more"></span></p>
<h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p>每一个实例对象的对象头，都有一个指针指向类对象（Class对象，在堆中，其中有类的静态变量），Class对象作为访问方法区中的类型数据的外部接口。</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/posts/e8eb0481.html</url>
    <content><![CDATA[<p>二分查找总结，模板和相关题<br><span id="more"></span></p>
<p><em>参考邓俊辉老师的《数据结构》56页</em></p>
<ol>
<li><p>返回第一个大于target值的索引</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//始终满足[0, lo) &lt;= target, [hi, n) &gt; target</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = n;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mi</span> <span class="operator">=</span> (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mi] &lt;= target)&#123;</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hi = mi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//最后lo == hi, 返回第一个大于target的索引，返回lo--为插入位置</span></span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回第一大于等于target值的索引</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//始终满足[0, lo) &lt; target, [hi, n) &gt;= target</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = n;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mi</span> <span class="operator">=</span> (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mi] &lt; target)&#123;</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hi = mi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//最后lo == hi, 返回第一大于等于target的索引</span></span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这两种情况应该够用了。右边界取n还是n-1看具体情况，返回第一个大于或大于等于的，下标可能在n（即所有数都比target小），[lo,hi]是所求的下标范围，能取到n那hi就定到n。</p>
<p>有时候mi需要向上取整，这就不记了</p>
<p>相关题：</p>
<ul>
<li>540，记住</li>
<li>153，比较mi和hi</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题-二叉树</title>
    <url>/posts/55daf129.html</url>
    <content><![CDATA[<p>二叉树的题，递归要熟悉<span id="more"></span></p>
<ul>
<li>543，617，112</li>
</ul>
<p>力扣437</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        Map&lt;Long, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0L</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> recur(root, targetSum, map, <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">recur</span><span class="params">(TreeNode root, <span class="type">int</span> target, Map&lt;Long, Integer&gt; map, Long curr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr += root.val;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.getOrDefault(curr - target, <span class="number">0</span>);</span><br><span class="line">        map.put(curr, map.getOrDefault(curr, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//map存储当前节点和祖先节点的前缀和，传给子节点</span></span><br><span class="line">        count += recur(root.left, target, map, curr);</span><br><span class="line">        count += recur(root.right, target, map, curr);</span><br><span class="line">        <span class="comment">//路径是向下的，回溯时要删除当前节点对应的前缀和</span></span><br><span class="line">        map.put(curr, map.get(curr) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>路径问题：求数量可以用前缀和，求所有结果还是dfs</strong></p>
<ul>
<li>109，用全局变量</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题-其他</title>
    <url>/posts/48339ee4.html</url>
    <content><![CDATA[<p>记录一些刷题中需要注意的小问题<span id="more"></span></p>
<ul>
<li>负数作被除数，-2 % 6 = -2，直接把负号加前面</li>
<li>（无符号右移）逻辑右移&gt;&gt;&gt;</li>
<li>机制转换，504，405</li>
<li>质数，204</li>
<li>Excel表问题，171，168</li>
<li>质因数，172</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题-分治</title>
    <url>/posts/756833e6.html</url>
    <content><![CDATA[<p>关于分治的题，就记住吧<br><span id="more"></span></p>
<ol>
<li>力扣241</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//空间换时间，防止重复计算</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">diffWaysToCompute</span><span class="params">(String expression)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(expression))&#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(expression);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> expression.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            list.add(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; ++i)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> expression.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(isOps(c))&#123;</span><br><span class="line">                List&lt;Integer&gt; left = diffWaysToCompute(expression.substring(<span class="number">0</span>, i));</span><br><span class="line">                List&lt;Integer&gt; right = diffWaysToCompute(expression.substring(i+<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l : left)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> r : right)&#123;</span><br><span class="line">                        list.add(caculate(c, l, r));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            list.add(Integer.valueOf(expression));</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(expression, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isOps</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">c</span> <span class="operator">=</span>= <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">caculate</span><span class="params">(<span class="type">char</span> c, <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l + r;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l - r;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> l * r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>力扣95</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;TreeNode&gt;[][] dp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> generate(<span class="number">1</span>, n, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, List&lt;TreeNode&gt;[][] dp)</span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//把特殊情况放前面，防止后面数组越界</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            list.add(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[start][end] != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[start][end];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;=end; ++i)&#123;</span><br><span class="line">            List&lt;TreeNode&gt; left = generate(start, i-<span class="number">1</span>, dp);</span><br><span class="line">            List&lt;TreeNode&gt; right = generate(i+<span class="number">1</span>, end, dp);</span><br><span class="line">            <span class="keyword">for</span>(TreeNode l : left)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode r : right)&#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(i);</span><br><span class="line">                    root.left = l;</span><br><span class="line">                    root.right = r;</span><br><span class="line">                    list.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[start][end] = list;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题-链表</title>
    <url>/posts/6db30a46.html</url>
    <content><![CDATA[<p>链表的题<span id="more"></span></p>
<ul>
<li>涉及到头节点的题，最好设一个dummy节点</li>
<li>24，445，234</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题-回溯</title>
    <url>/posts/b7ff5df1.html</url>
    <content><![CDATA[<p>回溯的题，这类题老是忘<span id="more"></span></p>
<ol>
<li><p>虽然不是回溯，<a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/">力扣1091</a></p>
<p>最短、最优解这些用广度优先搜索，找到所有解的两个都行，但一般还是深度优先搜索更好写。</p>
</li>
<li><p>深度优先搜索</p>
<p>力扣695， 200， 547， 130</p>
</li>
<li><p>回溯</p>
<p>力扣17， 93， 79， 257，46，47，77，39，216，78，90，131</p>
<p><a href="https://leetcode.cn/problems/restore-ip-addresses/submissions/">93题：复原IP地址</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(s, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), <span class="number">0</span>, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(String s, StringBuilder prefix, <span class="type">int</span> num, List&lt;String&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">4</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">4</span> &amp;&amp; s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">                list.add(prefix.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n &amp;&amp; i&lt;=<span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">curr</span> <span class="operator">=</span> s.substring(<span class="number">0</span>, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(Integer.valueOf(curr) &lt;= <span class="number">255</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">                    curr = <span class="string">&quot;.&quot;</span> + curr;</span><br><span class="line">                &#125;</span><br><span class="line">                prefix.append(curr);</span><br><span class="line">                backtrack(s.substring(i+<span class="number">1</span>), prefix, num+<span class="number">1</span>, list);</span><br><span class="line">                prefix.delete(prefix.length()-curr.length(), prefix.length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/binary-tree-paths/">力扣257</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, StringBuilder path, List&lt;String&gt; list)</span>&#123;</span><br><span class="line">        path.append(root.val + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            list.add(path.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            dfs(root.left, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(path).append(<span class="string">&quot;-&gt;&quot;</span>), list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            dfs(root.right, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(path).append(<span class="string">&quot;-&gt;&quot;</span>), list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/permutations-ii/">力扣47</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">          <span class="keyword">if</span>(!isVisited[i])&#123;</span><br><span class="line">              isVisited[i] = <span class="literal">true</span>;</span><br><span class="line">              path.add(nums[i]);</span><br><span class="line">              backtrack(nums, list, path, isVisited);</span><br><span class="line">              path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">              isVisited[i] = <span class="literal">false</span>;</span><br><span class="line">              <span class="comment">//111123, 回溯后，跳到最后一个1，for循环那还有一个++i，从2开始</span></span><br><span class="line">              <span class="keyword">while</span>(i &lt; n-<span class="number">1</span> &amp;&amp; nums[i] == nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                  ++i;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>有顺序的，排列：for循环从0开始</li>
<li>没顺序的，组合：for循环从start开始，传参</li>
</ul>
<p>​    <a href="https://leetcode.cn/problems/palindrome-partitioning/">力扣131</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrack(s, list, path);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(String s, List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(check(s, i))&#123;</span><br><span class="line">                path.add(s.substring(<span class="number">0</span>, i+<span class="number">1</span>));</span><br><span class="line">                backtrack(s.substring(i+<span class="number">1</span>), list, path);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String s, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = k;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i++) != s.charAt(j--))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer专项突击版刷题总结</title>
    <url>/posts/b59e3d2c.html</url>
    <content><![CDATA[<p>题解总结<br><span id="more"></span></p>
<ol>
<li>整数除法</li>
</ol>
<p>最后是都要取绝对值计算，先把特殊情况考虑到了；模拟草稿纸上的除法运算，比如10000/23，在百位上写4，余数就<strong>不可能</strong>在百位上写值了，是一个依次向低位上写值的过程，二进制一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == Integer.MIN_VALUE)&#123;</span><br><span class="line">            <span class="type">return</span> <span class="variable">a</span> <span class="operator">=</span>= Integer.MIN_VALUE ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a == Integer.MIN_VALUE)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b == -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(b == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                a += Math.abs(b);</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对布尔值可以做位运算，结果还是布尔值</span></span><br><span class="line">        <span class="comment">//int flag = (a &gt;&gt;&gt; 31) ^ (b &gt;&gt;&gt; 31)</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (a &gt; <span class="number">0</span>) ^ (b &gt; <span class="number">0</span>);</span><br><span class="line">        a = Math.abs(a);</span><br><span class="line">        b = Math.abs(b);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>; i&gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((a &gt;&gt;&gt; i) &gt;= b)&#123;</span><br><span class="line">                ans += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                a -= (b &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer刷题</title>
    <url>/posts/4f6f4f56.html</url>
    <content><![CDATA[<p>剑指offer从头刷一遍<span id="more"></span></p>
<ol>
<li><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指03</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组中重复的数字，当一个数和其下标不对应时，就把它交换到正确的位置，</span></span><br><span class="line"><span class="comment">//如果正确的位置有一个同样的值（就找到重复的了），</span></span><br><span class="line"><span class="comment">//while中每次都会有一个值处在正确的位置，时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] != i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[nums[i]] == nums[i])&#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                swap(nums, i, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">剑指07</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根节点以前序遍历下标为准，子树范围是中序遍历的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] preorder;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; inorderMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> inorder.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            inorderMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">recur</span><span class="params">(<span class="type">int</span> preRootIdx, <span class="type">int</span> inLeftIdx, <span class="type">int</span> inRightIdx)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inLeftIdx &gt; inRightIdx)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preRootVal</span> <span class="operator">=</span> preorder[preRootIdx];</span><br><span class="line">        <span class="type">int</span> <span class="variable">inRootIdx</span> <span class="operator">=</span> inorderMap.get(preRootVal);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preRootVal);</span><br><span class="line">        root.left = recur(preRootIdx+<span class="number">1</span>, inLeftIdx, inRootIdx-<span class="number">1</span>);</span><br><span class="line">        root.right = recur(preRootIdx + inRootIdx - inLeftIdx + <span class="number">1</span>, inRootIdx + <span class="number">1</span>, inRightIdx);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>剑指09：用两个栈实现队列。stack2只push，弹出时当stack1非空时弹出stack1，否则将stack2中所有元素出栈并入栈stack1，stack1再出栈。</p>
</li>
<li><p><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">154</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//旋转数组最小值，有重复</span></span><br><span class="line"><span class="comment">//比较mi和hi，相同时hi左移</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mi</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mi] &lt; nums[hi])&#123;</span><br><span class="line">                hi = mi;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mi] &gt; nums[hi])&#123;</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hi = hi - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><a href="https://leetcode.cn/problems/word-search/">79</a> 回溯的题</li>
<li><a href="https://leetcode.cn/problems/integer-break/">343整数拆分</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果一个因子大于4，拆成2和n-2一定更大</span></span><br><span class="line"><span class="comment">//4，拆成2+2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> n / <span class="number">3</span>, remainder = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(remainder == <span class="number">0</span>) <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>, a);</span><br><span class="line">        <span class="keyword">if</span>(remainder == <span class="number">1</span>) <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>, a-<span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>, a) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><a href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">二进制中1的个数</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//n &amp; (n-1)会消掉最低位的1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">快速幂</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            b = -b;</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                ans *= x;</span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">大数打印</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记住就完事了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] ans;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] printNumbers(<span class="type">int</span> n) &#123;</span><br><span class="line">        ans = <span class="keyword">new</span> <span class="title class_">int</span>[(<span class="type">int</span>)Math.pow(<span class="number">10</span>, n) - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">            dfs(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == len)&#123;</span><br><span class="line">            ans[count++] = Integer.parseInt(curr.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> (x == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;<span class="number">10</span>; ++i)&#123;</span><br><span class="line">            curr.append(i);</span><br><span class="line">            dfs(x+<span class="number">1</span>, len);</span><br><span class="line">            curr.deleteCharAt(curr.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://leetcode.cn/problems/regular-expression-matching/">正则表达式</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length(), n = p.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//s,p都为空默认匹配</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//s为空, p为.*也能匹配</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;=n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">2</span>) || p.charAt(j-<span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                        <span class="comment">//匹配0次或多次</span></span><br><span class="line">                        dp[i][j] = dp[i][j-<span class="number">2</span>] || dp[i-<span class="number">1</span>][j];</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//只能匹配0次</span></span><br><span class="line">                        dp[i][j] = dp[i][j-<span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">1</span>) || p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                        dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>周记 | 3.21-3.27</title>
    <url>/posts/2d5bb144.html</url>
    <content><![CDATA[<p>随便写写<br><span id="more"></span>这一周的学习状态很差，总是不能专注，想想两年前用两个多月时间从头学四门专业课，真挺厉害的，现在的我精神状态、身体状态都一般<br>如果说奶奶的离开是一种有无上的巨大落差，带来的是持久的消极情绪，昨天在听到了四年之前第一次听到的歌时，感受到的是无意中意识到自己的某些变化后的惊诧。四年来我确实变了很多，但具体是什么又很难具象捕捉，这变化如此显著却不可言说。重返袖珍时光的超级月亮，再次听到竟十分感动，当时还去红咖看了现场。变化开始于19年毕业时、还是20年入学后已不可考<br>具体而持续的行动总是让人感到充实，刷题、MySQL、并发等等，要学的东西很多。虽然自己并不着急，但确实错过了很多机会，四月份要多投简历争取找到份实习，清明之前把所有的都过一遍吧<br>没什么可写的了，昨天睡觉之前明明有很多想说的话。</p>
]]></content>
      <categories>
        <category>片段</category>
      </categories>
      <tags>
        <tag>周记</tag>
      </tags>
  </entry>
  <entry>
    <title>周记 | 5.9-5.15</title>
    <url>/posts/8de1ee47.html</url>
    <content><![CDATA[<p>随便写写<br><span id="more"></span>博客里大多是心情低落时上来瞎写，其实我是一个很乐观的人，只不过心情不太好的时候才想起来这个博客。以后经常写着点，要努力啊，要不然每天记录自己的划水日常？<br>五一之后这半个月好像什么都没干，不过跑通了那个qrtsc，汉化一下应该能应付毕业了嘿嘿。每周还要写点前端，我后悔之前说前端有意思了，调HTML能TM烦死人，好在下午把图片遍历弄好了。下周组会讲什么啊？每周的灵魂发问<br>你不会真的要摆烂吧？！七月就要开始提前批了，抓紧时间学习，这半个月得把那个小说爬虫的项目看明白，放到简历里还不错。下个月看看能不能把6.824给做完，能做多少是多少吧。刷题的感觉越来越差了，这点让我很担忧<br>每天都在自娱自乐，高强度网上冲浪，一抬头看见Ubuntu桌面就忍不住玩扫雷。米哈游你坏事做尽，大小号全歪<br>保持好心情，规律作息，今天是这周第一次熬夜，每周晚睡一天不过分。下周赶紧把操作系统和Redis看完，好好刷题！！！</p>
]]></content>
      <categories>
        <category>片段</category>
      </categories>
      <tags>
        <tag>周记</tag>
      </tags>
  </entry>
  <entry>
    <title>并发学习</title>
    <url>/posts/54cc7e1f.html</url>
    <content><![CDATA[<p>并发编程里的知识点<span id="more"></span></p>
<ol>
<li>volatile</li>
</ol>
<p>是jvm提供的轻量级的同步机制：保证可见性、<strong>不保证原子性</strong>、禁止指令重排序</p>
<p>可见性：一个线程修改了主内存的值，要通知其他线程</p>
<ol>
<li>synchronized</li>
</ol>
<p>普通同步方法，锁是当前实例对象；静态同步方法，锁是当前类的Class对象；同步方法块：锁是括号里的对象。</p>
<ul>
<li>同步代码：通过moniterenter、moniterexit 关联到到一个monitor对象，进入时设置Owner为当前线程，计数+1、退出-1。除了正常出口的 monitorexit，还在异常处理代码里插入了 monitorexit。</li>
<li>实例方法：隐式调用moniterenter、moniterexit（ACC_SYNCHRONIZED）</li>
<li>静态方法：隐式调用moniterenter、moniterexit</li>
</ul>
<p>每一个对象都关联一个monitor，执行monitorenter时，会尝试获得对象对应的monitor的所有权，即尝试获得对象的锁。</p>
<p>在 HotSpot 虚拟机中，对象在内存中的布局分为三块区域：对象头，实例数据和对齐填充。对象头中包含两部分：MarkWord 和 类型指针。如果是数组对象的话，对象头还有一部分是存储数组的长度。多线程下 synchronized 的加锁就是对同一个对象的对象头中的 MarkWord 中的变量进行CAS操作。</p>
<p><img src="https://tech.youzan.com/content/images/2021/06/image-20210627210825952.png" alt="mariword"></p>
<p>epoch: 偏向时间戳<strong>后面再查查资料</strong></p>
<p>如果当前锁<strong>已偏向其他线程</strong>||<strong>epoch值过期</strong>||<strong>class偏向模式关闭</strong>||<strong>获取偏向锁的过程中存在并发冲突</strong>，都会进入到<code>InterpreterRuntime::monitorenter</code>方法， 在该方法中会进行偏向锁撤销和升级。</p>
<p><img src="https://tech.youzan.com/content/images/2021/07/---.svg" alt=""></p>
<p><strong>只有匿名偏向的对象才能进入偏向锁模式</strong>。偏向锁是延时初始化的，默认是4000ms。初始化后会将所有加载的Klass的prototype header修改为匿名偏向样式。当创建一个对象时，会通过Klass的prototype_header来初始化该对象的对象头。简单的说，偏向锁初始化结束后，后续所有对象的对象头都为<strong>匿名偏向</strong>样式，在此之前创建的对象则为<strong>无锁状态</strong>。而对于无锁状态的锁对象，如果有竞争，会直接进入到轻量级锁。这也是为什么JVM启动前4秒对象会直接进入到轻量级锁的原因。</p>
<p>为什么需要延迟初始化？</p>
<p>JVM启动时必不可免会有大量sync的操作，而偏向锁并不是都有利。如果开启了偏向锁，会发生大量锁撤销和锁升级操作，大大降低JVM启动效率。</p>
<p>因此，我们可以明确地说，只有锁对象处于<strong>匿名偏向</strong>状态，线程才能拿到到我们通常意义上的偏向锁。而处于无锁状态的锁对象，只能进入到轻量级锁状态。</p>
<p>无锁状态只能升级为轻量级锁，<strong>匿名偏向状态</strong>才能进入到偏向锁</p>
<p>3.偏向锁<strong>并不都有利，</strong>其适用于<strong>单个线程重入</strong>的场景，原因为：偏向锁的撤销需要进入<code>safepoint</code>，开销较大。需要进入<code>safepoint</code>是由于，偏向锁的撤销需要对锁对象的<code>lock record</code>进行操作，而<code>lock record</code>要到每个线程的栈帧中遍历寻找。在非safepoint，栈帧是动态的，会引入更多的问题。目前看来，偏向锁存在的价值是为历史遗留的Collection类如Vector和HashTable等做优化，迟早药丸。Java 15中默认不开启。<br>4.执行Object类的<code>hashcode</code>方法，偏向锁撤销并且锁会膨胀为轻量级锁或者重量锁。执行Object类的<code>wait/notify/notifyall</code>方法，偏向锁撤销并膨胀成重量级锁。<br>5.轻量级锁适用于<strong>两个线程的交替执行</strong>场景：线程A进入轻量级锁，退出同步代码块并释放锁，会将锁对象恢复为无锁状态；线程B再进入锁，发现为无锁状态，会cas尝试获取该锁对象的轻量级锁。如果有竞争，则直接膨胀为重量级锁，没有自旋操作，详情看10。</p>
<p><a href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">Java锁与线程的那些事</a></p>
<p>这篇写得太好了，后面一定好好看看</p>
<ol>
<li>volatile</li>
</ol>
<p><strong>原理</strong>：首先我们要了解线程在java内存里面执行的原理，每个线程获取到CPU的时钟区间之后，会从ready状态-&gt;running状态，在x86处理器下，每个线程在执行的时候，不会直接读取主内存，而是会在每个CPU的高速缓存里面读取数据，每次CPU在执行线程的时候，会将需要的数据从主内存读取到高速缓存中，而在多核CPU的情况下，如果一个CPU进行了计算，然而其他CPU里面的缓存数据还是旧的，那么就会导致计算出错（脏数据）的情况，为了避免这种情况，保证多个CPU之间的高速缓存是一致的，OS里面会有一个<strong>缓存一致性协议</strong>，volatile就是通过OS的缓存一致性策略来保持共享变量在多个线程之间的可见性。</p>
<blockquote>
<p>缓存一致性：每个CPU会在总线上面有一个嗅探器，当一个CPU将高速缓存的内容写到主内存时候，每个CPU会去查看自己缓存里面的缓存行对应的内存地址的值是否被修改了，如果发现被修改了，会将缓存里面的数据设为无效，当处理器要对自身告诉缓存里面的这个数据进行修改，会强制重新从系统主内存读取数据进来之后再去修改（详细可参考intel的mesi协议：<a href="https://link.jianshu.com?t=http%3A%2F%2Fblog.csdn.net%2Fmuxiqingyang%2Farticle%2Fdetails%2F6615199">http://blog.csdn.net/muxiqingyang/article/details/6615199</a>）。</p>
</blockquote>
<p><strong>局限性</strong>：由于volatile只是保持了共享变量的可见性，当多线程并发的时候，多个线程分别分配到CPU中，比如执行x++操作，我们都知道实际上<strong>x++ &lt;=&gt; x=x+1</strong>，那么x++不是一个原子操作而是一个两步的操作，当对共享变量使用volatile之后，在CPU1里面一个线程进行了+1操作，并将数据写回到主内存时候，根据缓存一致性策略，会将各个其他CPU高速缓存里面的缓存行设为无效，然而当此时另一个线程已经完成了从CPU告诉缓存段读取数据到变量的操作，此时变量的值已经在jvm的栈里面，虽然CPU2里面的缓存段已经失效了，但是在并发情况下，还是可能会出现数据丢失的情况，不能保证并发情况下对共享变量的访问。</p>
<p><strong>使用场景</strong>：</p>
<blockquote>
<p>(1)对变量的写操作不依赖于当前值。</p>
<p>(2)该变量没有包含在具有其他变量的不变式中。</p>
<p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>
</blockquote>
<p>所以可以看出，实际上volatile作为只保证可见性的并发策略，只适用于独立的不依赖于当前值的变量，一般来说是只能适合于Boolean变量并且是独立的与其他互不相关的Boolean变量，当然自从jdk1.5之后，java引进了CAS机制来保证volatile的原子性。</p>
<p>volatile适合一个线程写，多个线程读</p>
<p>CAS比synchronized快</p>
<p>（1）CAS是一个硬件指令，通过硬件层次去保证原子性，比synchronized在jvm层次通过一个监听者作为锁来保证原子性更快</p>
<p>（2）OS里面的<strong>LOCK</strong>指令分为两种锁：</p>
<p>1.一种是<strong>总线锁</strong>，当LOCK指令锁住的是总线的时候，那么每一刻只有一个CPU能够访问到总线，那样就保证了原子性的操作，但是由于同一时刻只有一个CPU，就是单线程能访问到总线，但因为是硬件上层次的锁，所以性能还是优于synchronized；</p>
<p>2.另外一种是<strong>缓存锁</strong>，当cmpxchg指令要操作的内存能完全保存在一个缓存行里面的时候，CPU高速缓存里面也完全缓存了这个缓存行，当要对缓存行进行写操作之前，根据缓存一致性策略会将缓存行修改为MESI里面的E（Exclusive）状态，当缓存行处于这个状态的时候，其他CPU里面不能访问这个缓存行的数据，就是说此时这个缓存行是被锁定独占的，那么CAS就会就直接执行cmpxchg指令而不去发出LOCK指令到总线，因为是独占的占有这个缓存行，所以也是一个原子性的操作。而因为缓存行层次上的锁更具有并发性和锁的时间更短，所以性能上比synchronized要快的多。</p>
<p>所以当同步锁的性能还不是系统性能瓶颈的时候，可以先考虑使用同步锁synchronized和lock，但是当同步锁的性能已经是系统瓶颈，那就要开始考虑使用CAS+volatile的非阻塞乐观锁的方式来降低同步锁带来的阻塞性能的问题</p>
<p><a href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/</a></p>
<p><a href="https://www.jianshu.com/p/cd4744d799e4">https://www.jianshu.com/p/cd4744d799e4</a></p>
<p><a href="https://www.cnblogs.com/wuqinglong/p/9945618.html">https://www.cnblogs.com/wuqinglong/p/9945618.html</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统总结</title>
    <url>/posts/25519ab6.html</url>
    <content><![CDATA[<p>操作系统知识点总结<span id="more"></span></p>
<ol>
<li><strong>进程、线程、协程的区别</strong></li>
</ol>
<ul>
<li><p>进程指运行中的程序。一般我们希望同时运行多个程序，操作系统通过虚拟化CPU来提供这个假象，让一个进程只运行一个时间片，然后切换其他进程。进程是分配资源的单位，进程的机器状态（machine state，进程在运行时可以读取或更新的内容）：它的内存（地址空间）、寄存器。</p>
</li>
<li><p>线程是为单个进程提供的抽象，经典观点：一个程序只有一个执行点（一个PC），多线程程序有多个执行点（多个程序计数器，分别用于取指和执行），每个线程有一个程序计数器、一组寄存器。线程是调度的基本单位，把一个进程的资源分配和执行调度分开。线程间共享地址空间，能够访问相同的数据。</p>
</li>
</ul>
<p>​    (线程上下文切换类似于进程上下文切换，进程切换将状态保存到进程控制块（PCB），线程对应线程控制    块（TCB）。线程切换地址空间不变，不需要切换当前使用的页表。）</p>
<ul>
<li>java线程的实现基于内核线程（实际上是内核进程的一个接口：轻量级进程），各种线程操作、切换都要进行系统调用，代价较高，需要在用户态、内核态切换，同时也会消耗一定内核资源，容纳的线程数量有限。1：1</li>
</ul>
<p>​    协程：用户线程，1：N。用户线程的建立、同步、销毁和调度完全在用户态中完成。操作快、消耗低，但    实现上比较复杂，需要应用层实现的内容（调用栈、调度器）特别多。</p>
<p>​    HotSpot中，java线程直接映射到操作系统原生线程，抢占式调度，调度最终由操作系统说了算。</p>
<ol>
<li><strong>进程间通信方式</strong></li>
</ol>
<p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为<strong>进程间通信（IPC，InterProcess Communication）</strong></p>
<p><a href="https://www.jianshu.com/p/c1015f5ffa74">https://www.jianshu.com/p/c1015f5ffa74</a></p>
<p>1.匿名管道</p>
<p>2.有名管道</p>
<p>3.信号</p>
<p>4.消息队列（内核中）</p>
<p>5.共享内存：多个进程共享一段内存</p>
<p>6.信号量：用于进程同步</p>
<p>7.套接字</p>
<p>3.<strong>死锁的产生条件和解决方案</strong></p>
<p>多个进程可以竞争有限数量的资源。当一个进程申请资源时，如果这时没有可用资源，那么这个进程进入等待状态。有时，如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变状态。这种情况称为 死锁。</p>
<ul>
<li><strong>互斥</strong>：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</li>
<li><strong>占有并等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</li>
<li><strong>非抢占</strong>：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li>
<li><strong>循环等待</strong>：有一组等待进程 <code>&#123;P0, P1,..., Pn&#125;</code>， <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，……，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</li>
</ul>
<p>解决死锁的方法</p>
<ul>
<li><p><strong>预防</strong> 是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间上都不满足。</p>
<p>1.<strong>静态分配策略</strong>：破坏第二个条件。一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。降低了资源利用率</p>
<p>2.<strong>层次分配策略</strong>：破坏第二个条件。在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它才能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的</p>
</li>
<li><p><strong>死锁避免</strong></p>
<p>当一个进程申请使用资源的时候，<strong>银行家算法</strong> 通过先 <strong>试探</strong> 分配给该进程资源，然后通过 <strong>安全性算法</strong> 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 <strong>真的分配资源给该进程</strong>。需要花费较多的时间。</p>
</li>
<li><p>死锁检测</p>
<ol>
<li>如果进程-资源分配图中无环路，则此时系统没有发生死锁</li>
<li>如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁。</li>
<li>如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁。如果能在进程-资源分配图中找出一个 <strong>既不阻塞又非独立的进程</strong> ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 <strong>消除所有的边</strong> ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 <strong>拓扑排序</strong>)</li>
</ol>
</li>
<li><p>死锁解除</p>
<ol>
<li><strong>立即结束所有进程的执行，重新启动操作系统</strong> ：这种方法简单，但以前所在的工作全部作废，损失很大。</li>
<li><strong>撤销涉及死锁的所有进程，解除死锁后继续运行</strong> ：这种方法能彻底打破<strong>死锁的循环等待</strong>条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。</li>
<li><strong>逐个撤销涉及死锁的进程，回收其资源直至死锁解除。</strong></li>
<li><strong>抢占资源</strong> ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。</li>
</ol>
</li>
</ul>
<p>4.<strong>虚拟内存及其作用介绍</strong></p>
<p>操作系统提供了一个易用的物理内存抽象：地址空间。一个进程的地址空间包含运行程序的所有内存状态、代码、栈和堆。</p>
<p>为什么要有虚拟内存：方便和易用性、支持多个并发进程</p>
<p>3个目标：</p>
<p>1.透明：程序感觉不到内存被虚拟化的事实，好像拥有自己的内存。操作系统和硬件完成了所有的工作。</p>
<p>2.效率：时间上不会使程序执行得更慢，空间上不太需要额外的内存。依靠硬件支持。</p>
<p>3.保护：一个进程不会影响其他进程或操作系统的内存内容（它的地址空间之外的内容），对进程之间提供隔离。</p>
<p>5.<strong>线程间通信方式</strong></p>
<ol>
<li><strong>互斥量(Mutex)</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li>
<li><strong>信号量(Semphares)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li>
<li><strong>事件(Event)</strong> :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>
</ol>
<p>6.<strong>进程调度算法</strong></p>
<p>1.先进先出FIFO</p>
<p>2.最短任务优先：非抢占式</p>
<p>3.最短完成时间优先：抢占式</p>
<p>4.时间片轮转</p>
<p>5.多级反馈队列</p>
<p>规则 1：如果 A 的优先级 &gt; B 的优先级，运行 A（不运行 B）。</p>
<p> 规则 2：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B。 </p>
<p>规则 3：工作进入系统时，放在最高优先级（最上层队列）。 </p>
<p>规则 4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）。 </p>
<p>规则 5：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。</p>
<p>6.比例份额：确保每个工作获得一定比例的CPU时间。彩票份额、行程值</p>
<ol>
<li><strong>用户态内核态区别</strong></li>
</ol>
<p>用户空间:指的就是用户可以操作和访问的空间，这个空间通常存放我们用户自己写的数据等等；而内核空间则是系统内核来操作的一块空间，这块空间里面存放系统内核的函数、接口等。<br>不管对于Linux还是Windows， 他们都具有自己用户空间和内核空间。当一个程序运行时，如果它是在用户空间下执行，我们把此时运行得程序的这种状态成为用户态，而当这段程序执行在内核的空间执行时，这种状态称为内核态。</p>
<p>用户模式（user mode）。在用户模式下运行的代码会受到限制。例如，在用户模式下运行时，进程不能发出 I/O 请求。这 样做会导致处理器引发异常，操作系统可能会终止进程。与用户模式不同的内核模式（kernel mode），操作系统（或内核）就以这种模式运行。 在此模式下，运行的代码可以做它喜欢的事，包括特权操作，如发出 I/O 请求和执行所有类 型的受限指令。</p>
<p>作用1：安全执行受限制的指令</p>
<p>作用2：实现进程切换</p>
<ol>
<li><strong>进程的状态</strong></li>
</ol>
<p>1.创建</p>
<p>2.就绪</p>
<p>3.运行</p>
<p>4.阻塞</p>
<p>5.结束</p>
<ol>
<li><strong>如何实现进程间共享内存？</strong></li>
</ol>
<p>为了支持共享，需要一些额外的硬件支持，这就是保护位（protection bit）。基本为每个段增加了几个位，标识程序是否能够读写该段，或执行其中的代码。通过将代码段标记为只 读，同样的代码可以被多个进程共享，而不用担心破坏隔离。虽然每个进程都认为自己独占 这块内存，但操作系统秘密地共享了内存，进程不能修改这些内存，所以假象得以保持。</p>
<ul>
<li><p>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</p>
</li>
<li><p>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</p>
</li>
<li><p>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>原理</th>
<th>易失性</th>
</tr>
</thead>
<tbody>
<tr>
<td>mmap</td>
<td>利用文件(open)映射共享内存区域</td>
<td>会保存在磁盘上，不会丢失</td>
</tr>
<tr>
<td>Posix shared memory</td>
<td>利用/dev/shm文件系统(mmap)映射共享内存区域</td>
<td>随内核持续，内核自举后会丢失</td>
</tr>
<tr>
<td>SystemV shared memory</td>
<td>利用/dev/shm文件系统(shmat)映射共享内存区域</td>
<td>随内核持续，内核自举后会丢失</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><strong>线程状态</strong></li>
</ol>
<p>java线程状态：</p>
<p>1.新建：创建后未启动</p>
<p>2.运行：包括操作系统中的Running和Ready</p>
<p>3.无限期等待（wait）：线程主动等待</p>
<p>4.限期等待：带时间的wait、join等</p>
<p>5.阻塞：等待获得一个排他锁</p>
<p>6.结束（terminated）</p>
<ol>
<li><strong>内存泄露概念与产生原因与影响</strong></li>
</ol>
<p>为内存泄露（memory leak），如果忘记释放内存，就会发生。系统中实际存在两级内存管理。 第一级是由操作系统执行的内存管理，操作系统在进程运行时将内存交给进程，并在进程退出（或以其他方式结束）时将其回收。第二级管理在每个进程中，例如在调用 malloc()和 free()时，在堆内管理。 即使你没有调用 free()（并因此泄露了堆中的内存），操作系统也会在程序结束运行时，收回进程的所有 内存（包括用于代码、栈，以及相关堆的内存页）。无论地址空间中堆的状态如何，操作系统都会在进程终止时收回所有这些页面，从而确保即使没有释放内存，也不会丢失内存。 因此，对于短时间运行的程序，泄露内存通常不会导致任何操作问题（尽管它可能被认为是不好的形式）。如果你编写一个长期运行的服务器（例如 Web 服务器或数据库管理系统，它永远不会退出），泄露内存就是很大的问题，最终会导致应用程序在内存不足时崩溃。</p>
<ol>
<li><strong>如何查看端口占用</strong></li>
</ol>
<p>netstat</p>
<ol>
<li><strong>查看进程内存与CPU占用情况</strong></li>
</ol>
<p>top</p>
<ol>
<li><strong>内存溢出的产生原因与相关处理</strong></li>
</ol>
<p>没有分配足够的内存，有时称为缓冲区溢出。</p>
<p>在某些情况下，这是无害的，可能会覆盖不再使用的变量。在某些情况下，这些溢出可 能具有令人难以置信的危害，实实上是系统中许多安全漏洞的来源。在其他情况下， malloc 库总是分配一些额外的空间，因此你的程序实实上不会在其他某个变量的值上涂写， 并且工作得很好。还有一些情况下，该程序确实会发生故障和崩溃。</p>
<ol>
<li><strong>操作系统分页、分段、TLB</strong></li>
</ol>
<p>操作系统需要把进程的地址空间映射到物理内存，如果完全照搬，将会有大量的空间浪费。具体怎么映射，就有了分段、分页。</p>
<p>分段：需要多对基址、界限寄存器。会有外部碎片</p>
<p>分页：将地址空间划分为固定的大小。需要额外的一次内存访问。</p>
<p>TLB：用来解决分页中额外的一次内存访问</p>
<p><strong>页表太大</strong></p>
<ul>
<li>段页式</li>
<li>多级页表：与使用的地址空间成比例，更紧凑</li>
</ul>
<p>请求分页、请求分段：在硬盘上开辟一片空间用于物理页的移入和移出：交换空间。书P166</p>
<blockquote>
<p>正在运行的进程生成虚拟内存引用（用于获取指令 或访问数据），在这种情况下，硬件将其转换为物理地址，再从内存中获取所需数据。 硬件首先从虚拟地址获得 VPN，检查 TLB 是否匹配（TLB 命中），如果命中，则获得最终的物理地址并从内存中取回。这希望是常见情形，因为它很快（不需要额外的内存访问）。 如果在 TLB 中找不到 VPN（即 TLB 未命中），则硬件在内存中查找页表（使用页表基 址寄存器），并使用 VPN 查找该页的页表项（PTE）作为索引。如果页有效且存在于物理内存中，则硬件从 PTE 中获得 PFN，将其插入 TLB，并重试该指令，这次产生 TLB 命中。到现在为止还挺好。 但是，如果希望允许页交换到硬盘，必须添加更多的机制。具体来说，当硬件在 PTE 中查找时，可能发现页不在物理内存中。硬件（或操作系统，在软件管理 TLB 时）判断是否在内存中的方法，是通过页表项中的一条新信息，即存在位（present bit）。如果存在位设 置为 1，则表示该页存在于物理内存中，并且所有内容都如上所述进行。如果存在位设置为 零，则页不在内存中，而在硬盘上。访问不在物理内存中的页，这种行为通常被称为页错 误（page fault）。</p>
<p>如果一个页不存在，它已被交换到硬盘，在处理页错误的时候，操作系统需要将该页 交换到内存中。那么，问题来了：操作系统如何知道所需的页在哪儿？在许多系统中，页 表是存储这些信息最自然的地方。因此，操作系统可以用 PTE 中的某些位来存储硬盘地址， 这些位通常用来存储像页的 PFN 这样的数据。当操作系统接收到页错误时，它会在 PTE 中 查找地址，并将请求发送到硬盘，将页读取到内存中。</p>
</blockquote>
<ol>
<li>页面置换算法</li>
</ol>
<ul>
<li>最优替换策略：只用来做对比</li>
<li>先入先出</li>
<li>随机</li>
<li>LRU、LFU：P180，完美LRU实现代价较高</li>
<li>时钟算法：近似LRU</li>
</ul>
<ol>
<li>用户态如何切换到内核态</li>
</ol>
<p>每个进程都有一个内核栈，用来保存进程的上下文。P40</p>
<p><strong>进程切换的具体过程</strong>：P43，上下文的保存/恢复有两种。</p>
<ol>
<li><em>epoll底层原理*</em>：看cyc</li>
<li><strong>简述信号量机制</strong></li>
</ol>
<p>编写并发程序的强大而灵活的原语</p>
<ol>
<li>并发与并行的区别</li>
</ol>
<p>并发：一段时间</p>
<p>并行：同时</p>
<ol>
<li><p>系统调用的全过程：参考17</p>
</li>
<li><p>僵尸进程、孤儿进程</p>
</li>
</ol>
<p>孤儿进程</p>
<p>如果父进程先退出，子进程还没退出，那么子进程的父进程将变为init进程。（注：任何一个进程都必须有父进程）。</p>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>
<p>僵尸进程</p>
<p>如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。</p>
<p>设置<strong>僵尸进程的目</strong>的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵尸状态）。</p>
<ol>
<li>进程、线程切换的差别</li>
</ol>
<p>线程上下文切换类似于进程上下文切换，进程切换将状态保存到进程控制块（PCB），线程对应线程控制    块（TCB）。线程切换地址空间不变，不需要切换当前使用的页表。</p>
<ol>
<li>kill与kill -9的区别</li>
</ol>
<p>默认情况下<code>kill</code>命令的参数为-15， 代表的信号为<code>SIGTERM</code>，这是告诉进程你<strong>需要被关闭，请自行停止运行并退出</strong>；</p>
<p>而<code>kill -9</code>代表的信号是<code>SIGKILL</code>，表示进程被终止，需要<strong>立即退出</strong>；</p>
<p>因此<code>kill -9</code>表示强制杀死该进程，这个信号<strong>不能被捕获也不能被忽略</strong>。</p>
<ol>
<li>内存分配算法</li>
</ol>
<ul>
<li>最优匹配：遍历查找，性能较差。产生很多难以利用的小块</li>
<li>最差匹配：需要遍历、导致过量的碎片</li>
<li>首次匹配：速度优势、空闲块按内存地址排序</li>
<li>下次匹配：维护一个指针，指向上一个查找结束的位置，查找操作扩散到整个列表中去。</li>
</ul>
<ol>
<li>零拷贝原理</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>梦的现实延续</title>
    <url>/posts/459bb8ba.html</url>
    <content><![CDATA[<p>一个奇怪的梦，醒后作。<br><span id="more"></span></p>
<ol>
<li>在我的价值观里，积极向上、努力奋斗是正确的。</li>
<li>没有朝着正确的方向努力会让我难过不安(这里需要一个更准确的词)。</li>
<li>努力奋斗了也并不会改变很多，1中观点会持续受阻，我渐渐躺平。</li>
</ol>
<p>最后，这三个观点在可预见的时间里都不会改变，这些矛盾的想法、矛盾的内心想法与实际行动可能会让我在负面情绪中变得更消极<br>但我也坚持了其他的我认为正确的，保持坦诚、保持善良等等。写下这些其实和我的日常生活出入很大，我平时只会想到3，只是偶尔比如现在才会想到1和2，所以绝大多时候我都很开心，就算现在也是，我接受这样一个矛盾的自己<br>写下这些单纯地是怕我忘了1和2，因为我真的很少想着这些，前几天和朋友的聊天又无意中让我想到了这点。这是一种逃避吗，或许不是，但我的大脑自动忽略了它们，而在意识到后又感到一丝丝不安，当然这种感觉在变淡。遗忘可能导致我在未来情绪低落时找不到原因，当然这只能是原因之一或者压根不是<br>现实中，一些形而下的，如中午吃什么、投哪家实习、多线程原理等等都占据着我的时间;而一些形而上的，看书看电影听歌等带来的艺术体验，发呆时大脑里的瞬时想法，又让我不觉时间流逝<br>我的内心住着一个“白”，它没有任何价值判断，或许是完全的空白，这些年它逐渐长大，占据着我更多的时间空间<br>两点睡的，六点多就醒了，现在却很清醒。梦里我在永夜中躲避一场大屠杀，奶奶出现了，她的音容笑貌真实可感，我要好好保护她。再一次见面让我感到幸福，在清醒时分写下这些。</p>
]]></content>
      <categories>
        <category>片段</category>
      </categories>
      <tags>
        <tag>杂念</tag>
      </tags>
  </entry>
</search>
