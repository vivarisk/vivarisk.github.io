{"meta":{"title":"航向树冠层","subtitle":"","description":"行行重行行","author":"廿二","url":"https://vivarisk.github.io","root":"/"},"pages":[{"title":"about","date":"2022-11-06T07:53:06.000Z","updated":"2022-11-07T09:40:58.382Z","comments":true,"path":"about/index.html","permalink":"https://vivarisk.github.io/about/","excerpt":"","text":"关于我"},{"title":"分类","date":"2022-05-29T06:15:27.000Z","updated":"2022-05-29T06:48:56.798Z","comments":false,"path":"categories/index.html","permalink":"https://vivarisk.github.io/categories/","excerpt":"","text":""},{"title":"标签","date":"2022-05-29T06:10:41.000Z","updated":"2022-05-29T06:49:28.456Z","comments":false,"path":"tags/index.html","permalink":"https://vivarisk.github.io/tags/","excerpt":"","text":""},{"title":"","date":"2022-11-26T11:58:52.154Z","updated":"2022-11-26T11:58:52.154Z","comments":false,"path":"moments/index.html","permalink":"https://vivarisk.github.io/moments/","excerpt":"","text":"new Artitalk({ appId: 'KokvLbNkMYbL88A2icbpJyFI-MdYXbMMI', // Your LeanCloud appId appKey: 'oxHJ0cu8xqxSU8efO7BwskP9', // Your LeanCloud appKey serverURL: 'https://api.huangsl.fun', pageSize: 5, //每页评论数量 atComment: 0, //评论功能的开关 0（关闭），1（开启） motion: 0, })"}],"posts":[{"title":"剑指offer专项突击版刷题总结","slug":"剑指offer专项突击版刷题总结","date":"2022-08-14T12:23:40.000Z","updated":"2022-08-18T17:11:04.457Z","comments":true,"path":"posts/b59e3d2c.html","link":"","permalink":"https://vivarisk.github.io/posts/b59e3d2c","excerpt":"题解总结","text":"题解总结 整数除法 1//又重新开始刷剑指第二版了，这个暂停","categories":[{"name":"刷题","slug":"刷题","permalink":"https://vivarisk.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"并发学习","slug":"并发学习","date":"2022-06-16T13:35:45.000Z","updated":"2022-08-18T17:09:15.071Z","comments":true,"path":"posts/54cc7e1f.html","link":"","permalink":"https://vivarisk.github.io/posts/54cc7e1f","excerpt":"并发编程里的知识点","text":"并发编程里的知识点 volatile 是jvm提供的轻量级的同步机制：保证可见性、不保证原子性、禁止指令重排序 可见性：一个线程修改了主内存的值，要通知其他线程 synchronized 普通同步方法，锁是当前实例对象；静态同步方法，锁是当前类的Class对象；同步方法块：锁是括号里的对象。 同步代码：通过moniterenter、moniterexit 关联到到一个monitor对象，进入时设置Owner为当前线程，计数+1、退出-1。除了正常出口的 monitorexit，还在异常处理代码里插入了 monitorexit。 实例方法：隐式调用moniterenter、moniterexit（ACC_SYNCHRONIZED） 静态方法：隐式调用moniterenter、moniterexit 每一个对象都关联一个monitor，执行monitorenter时，会尝试获得对象对应的monitor的所有权，即尝试获得对象的锁。 在 HotSpot 虚拟机中，对象在内存中的布局分为三块区域：对象头，实例数据和对齐填充。对象头中包含两部分：MarkWord 和 类型指针。如果是数组对象的话，对象头还有一部分是存储数组的长度。多线程下 synchronized 的加锁就是对同一个对象的对象头中的 MarkWord 中的变量进行CAS操作。 epoch: 偏向时间戳后面再查查资料 如果当前锁已偏向其他线程||epoch值过期||class偏向模式关闭||获取偏向锁的过程中存在并发冲突，都会进入到InterpreterRuntime::monitorenter方法， 在该方法中会进行偏向锁撤销和升级。 只有匿名偏向的对象才能进入偏向锁模式。偏向锁是延时初始化的，默认是4000ms。初始化后会将所有加载的Klass的prototype header修改为匿名偏向样式。当创建一个对象时，会通过Klass的prototype_header来初始化该对象的对象头。简单的说，偏向锁初始化结束后，后续所有对象的对象头都为匿名偏向样式，在此之前创建的对象则为无锁状态。而对于无锁状态的锁对象，如果有竞争，会直接进入到轻量级锁。这也是为什么JVM启动前4秒对象会直接进入到轻量级锁的原因。 为什么需要延迟初始化？ JVM启动时必不可免会有大量sync的操作，而偏向锁并不是都有利。如果开启了偏向锁，会发生大量锁撤销和锁升级操作，大大降低JVM启动效率。 因此，我们可以明确地说，只有锁对象处于匿名偏向状态，线程才能拿到到我们通常意义上的偏向锁。而处于无锁状态的锁对象，只能进入到轻量级锁状态。 无锁状态只能升级为轻量级锁，匿名偏向状态才能进入到偏向锁 3.偏向锁并不都有利，其适用于单个线程重入的场景，原因为：偏向锁的撤销需要进入safepoint，开销较大。需要进入safepoint是由于，偏向锁的撤销需要对锁对象的lock record进行操作，而lock record要到每个线程的栈帧中遍历寻找。在非safepoint，栈帧是动态的，会引入更多的问题。目前看来，偏向锁存在的价值是为历史遗留的Collection类如Vector和HashTable等做优化，迟早药丸。Java 15中默认不开启。4.执行Object类的hashcode方法，偏向锁撤销并且锁会膨胀为轻量级锁或者重量锁。执行Object类的wait/notify/notifyall方法，偏向锁撤销并膨胀成重量级锁。5.轻量级锁适用于两个线程的交替执行场景：线程A进入轻量级锁，退出同步代码块并释放锁，会将锁对象恢复为无锁状态；线程B再进入锁，发现为无锁状态，会cas尝试获取该锁对象的轻量级锁。如果有竞争，则直接膨胀为重量级锁，没有自旋操作，详情看10。 Java锁与线程的那些事 这篇写得太好了，后面一定好好看看 volatile 原理：首先我们要了解线程在java内存里面执行的原理，每个线程获取到CPU的时钟区间之后，会从ready状态-&gt;running状态，在x86处理器下，每个线程在执行的时候，不会直接读取主内存，而是会在每个CPU的高速缓存里面读取数据，每次CPU在执行线程的时候，会将需要的数据从主内存读取到高速缓存中，而在多核CPU的情况下，如果一个CPU进行了计算，然而其他CPU里面的缓存数据还是旧的，那么就会导致计算出错（脏数据）的情况，为了避免这种情况，保证多个CPU之间的高速缓存是一致的，OS里面会有一个缓存一致性协议，volatile就是通过OS的缓存一致性策略来保持共享变量在多个线程之间的可见性。 缓存一致性：每个CPU会在总线上面有一个嗅探器，当一个CPU将高速缓存的内容写到主内存时候，每个CPU会去查看自己缓存里面的缓存行对应的内存地址的值是否被修改了，如果发现被修改了，会将缓存里面的数据设为无效，当处理器要对自身告诉缓存里面的这个数据进行修改，会强制重新从系统主内存读取数据进来之后再去修改（详细可参考intel的mesi协议：http://blog.csdn.net/muxiqingyang/article/details/6615199）。 局限性：由于volatile只是保持了共享变量的可见性，当多线程并发的时候，多个线程分别分配到CPU中，比如执行x++操作，我们都知道实际上x++ &lt;=&gt; x=x+1，那么x++不是一个原子操作而是一个两步的操作，当对共享变量使用volatile之后，在CPU1里面一个线程进行了+1操作，并将数据写回到主内存时候，根据缓存一致性策略，会将各个其他CPU高速缓存里面的缓存行设为无效，然而当此时另一个线程已经完成了从CPU告诉缓存段读取数据到变量的操作，此时变量的值已经在jvm的栈里面，虽然CPU2里面的缓存段已经失效了，但是在并发情况下，还是可能会出现数据丢失的情况，不能保证并发情况下对共享变量的访问。 使用场景： (1)对变量的写操作不依赖于当前值。 (2)该变量没有包含在具有其他变量的不变式中。 实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。 所以可以看出，实际上volatile作为只保证可见性的并发策略，只适用于独立的不依赖于当前值的变量，一般来说是只能适合于Boolean变量并且是独立的与其他互不相关的Boolean变量，当然自从jdk1.5之后，java引进了CAS机制来保证volatile的原子性。 volatile适合一个线程写，多个线程读 CAS比synchronized快 （1）CAS是一个硬件指令，通过硬件层次去保证原子性，比synchronized在jvm层次通过一个监听者作为锁来保证原子性更快 （2）OS里面的LOCK指令分为两种锁： 1.一种是总线锁，当LOCK指令锁住的是总线的时候，那么每一刻只有一个CPU能够访问到总线，那样就保证了原子性的操作，但是由于同一时刻只有一个CPU，就是单线程能访问到总线，但因为是硬件上层次的锁，所以性能还是优于synchronized； 2.另外一种是缓存锁，当cmpxchg指令要操作的内存能完全保存在一个缓存行里面的时候，CPU高速缓存里面也完全缓存了这个缓存行，当要对缓存行进行写操作之前，根据缓存一致性策略会将缓存行修改为MESI里面的E（Exclusive）状态，当缓存行处于这个状态的时候，其他CPU里面不能访问这个缓存行的数据，就是说此时这个缓存行是被锁定独占的，那么CAS就会就直接执行cmpxchg指令而不去发出LOCK指令到总线，因为是独占的占有这个缓存行，所以也是一个原子性的操作。而因为缓存行层次上的锁更具有并发性和锁的时间更短，所以性能上比synchronized要快的多。 所以当同步锁的性能还不是系统性能瓶颈的时候，可以先考虑使用同步锁synchronized和lock，但是当同步锁的性能已经是系统瓶颈，那就要开始考虑使用CAS+volatile的非阻塞乐观锁的方式来降低同步锁带来的阻塞性能的问题 https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/ https://www.jianshu.com/p/cd4744d799e4 https://www.cnblogs.com/wuqinglong/p/9945618.html","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://vivarisk.github.io/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"MySQL笔记","slug":"MySQL笔记","date":"2022-06-16T10:56:24.000Z","updated":"2022-08-18T17:09:15.062Z","comments":true,"path":"posts/fd5f561d.html","link":"","permalink":"https://vivarisk.github.io/posts/fd5f561d","excerpt":"MySQL学习过程中的一些知识点","text":"MySQL学习过程中的一些知识点 全部使用长连接，内存占用问题 1.定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后， 断开连接，之后要查询再重连。 2.如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执 行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权 限验证，但是会将连接恢复到刚刚创建完时的状态。 为什么不建议使用查询缓存 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清 空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新 压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很 长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。 Write-Ahead Logging: 先写日志，再写磁盘 redolog只是完成了prepare, 而binlog又失败，那么事务本身会回滚 1 prepare阶段 2 写binlog 3 commit 当在2之前崩溃时 重启恢复：后发现没有commit，回滚。备份恢复：没有binlog 。 一致 当在3之前崩溃 重启恢复：虽没有commit，但满足prepare和binlog完整，所以重启后会自动commit。备份：有binlog. 一致 一天一备份、一周一备份 RTO（恢复目标时间）好处是“最长恢复时间”更短。 在一天一备的模式里，最坏情况下需要应用一天的 binlog。当然这个是有成本的，因为更频繁全量备份需要消耗更多存储空间，所以这个 RTO 是成 本换来的，就需要你根据业务重要性来评估了。","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://vivarisk.github.io/tags/MySQL/"}]},{"title":"剑指offer刷题","slug":"剑指offer刷题","date":"2022-06-16T02:53:07.000Z","updated":"2022-11-07T05:51:48.016Z","comments":true,"path":"posts/4f6f4f56.html","link":"","permalink":"https://vivarisk.github.io/posts/4f6f4f56","excerpt":"剑指offer从头刷一遍","text":"剑指offer从头刷一遍 剑指031234567891011121314151617//数组中重复的数字，当一个数和其下标不对应时，就把它交换到正确的位置，//如果正确的位置有一个同样的值（就找到重复的了），//while中每次都会有一个值处在正确的位置，时间复杂度O(n)class Solution &#123; public int findRepeatNumber(int[] nums) &#123; int n = nums.length; for(int i=0; i&lt;n; ++i)&#123; while(nums[i] != i)&#123; if(nums[nums[i]] == nums[i])&#123; return nums[i]; &#125; swap(nums, i, nums[i]); &#125; &#125; return -1; &#125;&#125; 剑指071234567891011121314151617181920212223242526//根节点以前序遍历下标为准，子树范围是中序遍历的class Solution &#123; private int[] preorder; private Map&lt;Integer, Integer&gt; inorderMap = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] preorder, int[] inorder) &#123; this.preorder = preorder; int n = inorder.length; for(int i=0; i&lt;n; ++i)&#123; inorderMap.put(inorder[i], i); &#125; return recur(0, 0, n-1); &#125; private TreeNode recur(int preRootIdx, int inLeftIdx, int inRightIdx)&#123; if(inLeftIdx &gt; inRightIdx)&#123; return null; &#125; int preRootVal = preorder[preRootIdx]; int inRootIdx = inorderMap.get(preRootVal); TreeNode root = new TreeNode(preRootVal); root.left = recur(preRootIdx+1, inLeftIdx, inRootIdx-1); root.right = recur(preRootIdx + inRootIdx - inLeftIdx + 1, inRootIdx + 1, inRightIdx); return root; &#125;&#125; 剑指09：用两个栈实现队列。stack2只push，弹出时当stack1非空时弹出stack1，否则将stack2中所有元素出栈并入栈stack1，stack1再出栈。 154 123456789101112131415161718//旋转数组最小值，有重复//比较mi和hi，相同时hi左移class Solution &#123; public int findMin(int[] nums) &#123; int lo = 0, hi = nums.length - 1; while(lo &lt; hi) &#123; int mi = lo + (hi - lo) / 2; if(nums[mi] &lt; nums[hi])&#123; hi = mi; &#125;else if(nums[mi] &gt; nums[hi])&#123; lo = mi + 1; &#125;else&#123; hi = hi - 1; &#125; &#125; return nums[lo]; &#125;&#125; 79 回溯的题 343整数拆分12345678910111213//如果一个因子大于4，拆成2和n-2一定更大//4，拆成2+2class Solution &#123; public int integerBreak(int n) &#123; if(n &lt; 4)&#123; return n - 1; &#125; int a = n / 3, remainder = n % 3; if(remainder == 0) return (int)Math.pow(3, a); if(remainder == 1) return (int)Math.pow(3, a-1) * 4; return (int)Math.pow(3, a) * 2; &#125;&#125; 二进制中1的个数123456789101112//n &amp; (n-1)会消掉最低位的1class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; int count = 0; while(n != 0)&#123; n = n &amp; (n - 1); ++count; &#125; return count; &#125;&#125; 快速幂123456789101112131415161718class Solution &#123; public double myPow(double x, int n) &#123; double ans = 1.0; long b = n; if(b &lt; 0)&#123; b = -b; x = 1/x; &#125; while(b != 0)&#123; if((b &amp; 1) == 1)&#123; ans *= x; &#125; x *= x; b &gt;&gt;= 1; &#125; return ans; &#125;&#125; 大数打印 123456789101112131415161718192021222324252627//记住就完事了class Solution &#123; private StringBuilder curr = new StringBuilder(); private int[] ans; private int count = 0; public int[] printNumbers(int n) &#123; ans = new int[(int)Math.pow(10, n) - 1]; for(int i=1; i&lt;=n; ++i)&#123; dfs(0, i); &#125; return ans; &#125; private void dfs(int x, int len) &#123; if(x == len)&#123; ans[count++] = Integer.parseInt(curr.toString()); return; &#125; int start = (x == 0 ? 1 : 0); for(int i=start; i&lt;10; ++i)&#123; curr.append(i); dfs(x+1, len); curr.deleteCharAt(curr.length()-1); &#125; &#125;&#125; 正则表达式 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public boolean isMatch(String s, String p) &#123; int m = s.length(), n = p.length(); boolean[][] dp = new boolean[m+1][n+1]; //s,p都为空默认匹配 dp[0][0] = true; //s为空, p为.*也能匹配 for(int j = 1; j&lt;=n; ++j)&#123; if(p.charAt(j-1) == &#x27;*&#x27;)&#123; dp[0][j] = dp[0][j-2]; &#125; &#125; for(int j=1; j&lt;=n; ++j)&#123; for(int i=1; i&lt;=m; ++i)&#123; if(p.charAt(j-1) == &#x27;*&#x27;)&#123; if(s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == &#x27;.&#x27;)&#123; //匹配0次或多次 dp[i][j] = dp[i][j-2] || dp[i-1][j]; &#125;else&#123; //只能匹配0次 dp[i][j] = dp[i][j-2]; &#125; &#125;else&#123; if(s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == &#x27;.&#x27;)&#123; dp[i][j] = dp[i-1][j-1]; &#125; &#125; &#125; &#125; return dp[m][n]; &#125;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://vivarisk.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://vivarisk.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"jvm总结","slug":"jvm总结","date":"2022-06-12T03:24:47.000Z","updated":"2022-08-18T17:09:15.065Z","comments":true,"path":"posts/d6085898.html","link":"","permalink":"https://vivarisk.github.io/posts/d6085898","excerpt":"jvm学习中的一些知识点","text":"jvm学习中的一些知识点 Java内存区域每一个实例对象的对象头，都有一个指针指向类对象（Class对象，在堆中，其中有类的静态变量），Class对象作为访问方法区中的类型数据的外部接口。","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://vivarisk.github.io/tags/jvm/"}]},{"title":"刷题-二叉树","slug":"刷题-二叉树","date":"2022-06-09T05:01:03.000Z","updated":"2022-08-18T17:09:15.067Z","comments":true,"path":"posts/55daf129.html","link":"","permalink":"https://vivarisk.github.io/posts/55daf129","excerpt":"二叉树的题，递归要熟悉","text":"二叉树的题，递归要熟悉 543，617，112 力扣437 12345678910111213141516171819202122class Solution &#123; public int pathSum(TreeNode root, int targetSum) &#123; Map&lt;Long, Integer&gt; map = new HashMap&lt;&gt;(); map.put(0L, 1); return recur(root, targetSum, map, 0L); &#125; private int recur(TreeNode root, int target, Map&lt;Long, Integer&gt; map, Long curr)&#123; if(root == null)&#123; return 0; &#125; curr += root.val; int count = map.getOrDefault(curr - target, 0); map.put(curr, map.getOrDefault(curr, 0) + 1); //map存储当前节点和祖先节点的前缀和，传给子节点 count += recur(root.left, target, map, curr); count += recur(root.right, target, map, curr); //路径是向下的，回溯时要删除当前节点对应的前缀和 map.put(curr, map.get(curr) - 1); return count; &#125;&#125; 路径问题：求数量可以用前缀和，求所有结果还是dfs 109，用全局变量","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://vivarisk.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://vivarisk.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"刷题-链表","slug":"刷题-链表","date":"2022-06-08T07:07:53.000Z","updated":"2022-08-18T17:09:15.069Z","comments":true,"path":"posts/6db30a46.html","link":"","permalink":"https://vivarisk.github.io/posts/6db30a46","excerpt":"链表的题","text":"链表的题 涉及到头节点的题，最好设一个dummy节点 24，445，234","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://vivarisk.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"链表","slug":"链表","permalink":"https://vivarisk.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"操作系统总结","slug":"操作系统总结","date":"2022-06-06T08:00:11.000Z","updated":"2022-08-18T17:09:15.072Z","comments":true,"path":"posts/25519ab6.html","link":"","permalink":"https://vivarisk.github.io/posts/25519ab6","excerpt":"操作系统知识点总结","text":"操作系统知识点总结 进程、线程、协程的区别 进程指运行中的程序。一般我们希望同时运行多个程序，操作系统通过虚拟化CPU来提供这个假象，让一个进程只运行一个时间片，然后切换其他进程。进程是分配资源的单位，进程的机器状态（machine state，进程在运行时可以读取或更新的内容）：它的内存（地址空间）、寄存器。 线程是为单个进程提供的抽象，经典观点：一个程序只有一个执行点（一个PC），多线程程序有多个执行点（多个程序计数器，分别用于取指和执行），每个线程有一个程序计数器、一组寄存器。线程是调度的基本单位，把一个进程的资源分配和执行调度分开。线程间共享地址空间，能够访问相同的数据。 ​ (线程上下文切换类似于进程上下文切换，进程切换将状态保存到进程控制块（PCB），线程对应线程控制 块（TCB）。线程切换地址空间不变，不需要切换当前使用的页表。） java线程的实现基于内核线程（实际上是内核进程的一个接口：轻量级进程），各种线程操作、切换都要进行系统调用，代价较高，需要在用户态、内核态切换，同时也会消耗一定内核资源，容纳的线程数量有限。1：1 ​ 协程：用户线程，1：N。用户线程的建立、同步、销毁和调度完全在用户态中完成。操作快、消耗低，但 实现上比较复杂，需要应用层实现的内容（调用栈、调度器）特别多。 ​ HotSpot中，java线程直接映射到操作系统原生线程，抢占式调度，调度最终由操作系统说了算。 进程间通信方式 每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication） https://www.jianshu.com/p/c1015f5ffa74 1.匿名管道 2.有名管道 3.信号 4.消息队列（内核中） 5.共享内存：多个进程共享一段内存 6.信号量：用于进程同步 7.套接字 3.死锁的产生条件和解决方案 多个进程可以竞争有限数量的资源。当一个进程申请资源时，如果这时没有可用资源，那么这个进程进入等待状态。有时，如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变状态。这种情况称为 死锁。 互斥：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。 占有并等待：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。 非抢占：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。 循环等待：有一组等待进程 &#123;P0, P1,..., Pn&#125;， P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，……，Pn-1 等待的资源被 Pn 占有，Pn 等待的资源被 P0 占有。 解决死锁的方法 预防 是采用某种策略，限制并发进程对资源的请求，从而使得死锁的必要条件在系统执行的任何时间上都不满足。 1.静态分配策略：破坏第二个条件。一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。降低了资源利用率 2.层次分配策略：破坏第二个条件。在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它才能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的 死锁避免 当一个进程申请使用资源的时候，银行家算法 通过先 试探 分配给该进程资源，然后通过 安全性算法 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 真的分配资源给该进程。需要花费较多的时间。 死锁检测 如果进程-资源分配图中无环路，则此时系统没有发生死锁 如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁。 如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁。如果能在进程-资源分配图中找出一个 既不阻塞又非独立的进程 ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 消除所有的边 ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 拓扑排序) 死锁解除 立即结束所有进程的执行，重新启动操作系统 ：这种方法简单，但以前所在的工作全部作废，损失很大。 撤销涉及死锁的所有进程，解除死锁后继续运行 ：这种方法能彻底打破死锁的循环等待条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。 逐个撤销涉及死锁的进程，回收其资源直至死锁解除。 抢占资源 ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。 4.虚拟内存及其作用介绍 操作系统提供了一个易用的物理内存抽象：地址空间。一个进程的地址空间包含运行程序的所有内存状态、代码、栈和堆。 为什么要有虚拟内存：方便和易用性、支持多个并发进程 3个目标： 1.透明：程序感觉不到内存被虚拟化的事实，好像拥有自己的内存。操作系统和硬件完成了所有的工作。 2.效率：时间上不会使程序执行得更慢，空间上不太需要额外的内存。依靠硬件支持。 3.保护：一个进程不会影响其他进程或操作系统的内存内容（它的地址空间之外的内容），对进程之间提供隔离。 5.线程间通信方式 互斥量(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。 信号量(Semphares) ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。 事件(Event) :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。 6.进程调度算法 1.先进先出FIFO 2.最短任务优先：非抢占式 3.最短完成时间优先：抢占式 4.时间片轮转 5.多级反馈队列 规则 1：如果 A 的优先级 &gt; B 的优先级，运行 A（不运行 B）。 规则 2：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B。 规则 3：工作进入系统时，放在最高优先级（最上层队列）。 规则 4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）。 规则 5：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。 6.比例份额：确保每个工作获得一定比例的CPU时间。彩票份额、行程值 用户态内核态区别 用户空间:指的就是用户可以操作和访问的空间，这个空间通常存放我们用户自己写的数据等等；而内核空间则是系统内核来操作的一块空间，这块空间里面存放系统内核的函数、接口等。不管对于Linux还是Windows， 他们都具有自己用户空间和内核空间。当一个程序运行时，如果它是在用户空间下执行，我们把此时运行得程序的这种状态成为用户态，而当这段程序执行在内核的空间执行时，这种状态称为内核态。 用户模式（user mode）。在用户模式下运行的代码会受到限制。例如，在用户模式下运行时，进程不能发出 I/O 请求。这 样做会导致处理器引发异常，操作系统可能会终止进程。与用户模式不同的内核模式（kernel mode），操作系统（或内核）就以这种模式运行。 在此模式下，运行的代码可以做它喜欢的事，包括特权操作，如发出 I/O 请求和执行所有类 型的受限指令。 作用1：安全执行受限制的指令 作用2：实现进程切换 进程的状态 1.创建 2.就绪 3.运行 4.阻塞 5.结束 如何实现进程间共享内存？ 为了支持共享，需要一些额外的硬件支持，这就是保护位（protection bit）。基本为每个段增加了几个位，标识程序是否能够读写该段，或执行其中的代码。通过将代码段标记为只 读，同样的代码可以被多个进程共享，而不用担心破坏隔离。虽然每个进程都认为自己独占 这块内存，但操作系统秘密地共享了内存，进程不能修改这些内存，所以假象得以保持。 使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。 为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。 由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。 类型 原理 易失性 mmap 利用文件(open)映射共享内存区域 会保存在磁盘上，不会丢失 Posix shared memory 利用/dev/shm文件系统(mmap)映射共享内存区域 随内核持续，内核自举后会丢失 SystemV shared memory 利用/dev/shm文件系统(shmat)映射共享内存区域 随内核持续，内核自举后会丢失 线程状态 java线程状态： 1.新建：创建后未启动 2.运行：包括操作系统中的Running和Ready 3.无限期等待（wait）：线程主动等待 4.限期等待：带时间的wait、join等 5.阻塞：等待获得一个排他锁 6.结束（terminated） 内存泄露概念与产生原因与影响 为内存泄露（memory leak），如果忘记释放内存，就会发生。系统中实际存在两级内存管理。 第一级是由操作系统执行的内存管理，操作系统在进程运行时将内存交给进程，并在进程退出（或以其他方式结束）时将其回收。第二级管理在每个进程中，例如在调用 malloc()和 free()时，在堆内管理。 即使你没有调用 free()（并因此泄露了堆中的内存），操作系统也会在程序结束运行时，收回进程的所有 内存（包括用于代码、栈，以及相关堆的内存页）。无论地址空间中堆的状态如何，操作系统都会在进程终止时收回所有这些页面，从而确保即使没有释放内存，也不会丢失内存。 因此，对于短时间运行的程序，泄露内存通常不会导致任何操作问题（尽管它可能被认为是不好的形式）。如果你编写一个长期运行的服务器（例如 Web 服务器或数据库管理系统，它永远不会退出），泄露内存就是很大的问题，最终会导致应用程序在内存不足时崩溃。 如何查看端口占用 netstat 查看进程内存与CPU占用情况 top 内存溢出的产生原因与相关处理 没有分配足够的内存，有时称为缓冲区溢出。 在某些情况下，这是无害的，可能会覆盖不再使用的变量。在某些情况下，这些溢出可 能具有令人难以置信的危害，实实上是系统中许多安全漏洞的来源。在其他情况下， malloc 库总是分配一些额外的空间，因此你的程序实实上不会在其他某个变量的值上涂写， 并且工作得很好。还有一些情况下，该程序确实会发生故障和崩溃。 操作系统分页、分段、TLB 操作系统需要把进程的地址空间映射到物理内存，如果完全照搬，将会有大量的空间浪费。具体怎么映射，就有了分段、分页。 分段：需要多对基址、界限寄存器。会有外部碎片 分页：将地址空间划分为固定的大小。需要额外的一次内存访问。 TLB：用来解决分页中额外的一次内存访问 页表太大 段页式 多级页表：与使用的地址空间成比例，更紧凑 请求分页、请求分段：在硬盘上开辟一片空间用于物理页的移入和移出：交换空间。书P166 正在运行的进程生成虚拟内存引用（用于获取指令 或访问数据），在这种情况下，硬件将其转换为物理地址，再从内存中获取所需数据。 硬件首先从虚拟地址获得 VPN，检查 TLB 是否匹配（TLB 命中），如果命中，则获得最终的物理地址并从内存中取回。这希望是常见情形，因为它很快（不需要额外的内存访问）。 如果在 TLB 中找不到 VPN（即 TLB 未命中），则硬件在内存中查找页表（使用页表基 址寄存器），并使用 VPN 查找该页的页表项（PTE）作为索引。如果页有效且存在于物理内存中，则硬件从 PTE 中获得 PFN，将其插入 TLB，并重试该指令，这次产生 TLB 命中。到现在为止还挺好。 但是，如果希望允许页交换到硬盘，必须添加更多的机制。具体来说，当硬件在 PTE 中查找时，可能发现页不在物理内存中。硬件（或操作系统，在软件管理 TLB 时）判断是否在内存中的方法，是通过页表项中的一条新信息，即存在位（present bit）。如果存在位设 置为 1，则表示该页存在于物理内存中，并且所有内容都如上所述进行。如果存在位设置为 零，则页不在内存中，而在硬盘上。访问不在物理内存中的页，这种行为通常被称为页错 误（page fault）。 如果一个页不存在，它已被交换到硬盘，在处理页错误的时候，操作系统需要将该页 交换到内存中。那么，问题来了：操作系统如何知道所需的页在哪儿？在许多系统中，页 表是存储这些信息最自然的地方。因此，操作系统可以用 PTE 中的某些位来存储硬盘地址， 这些位通常用来存储像页的 PFN 这样的数据。当操作系统接收到页错误时，它会在 PTE 中 查找地址，并将请求发送到硬盘，将页读取到内存中。 页面置换算法 最优替换策略：只用来做对比 先入先出 随机 LRU、LFU：P180，完美LRU实现代价较高 时钟算法：近似LRU 用户态如何切换到内核态 每个进程都有一个内核栈，用来保存进程的上下文。P40 进程切换的具体过程：P43，上下文的保存/恢复有两种。 epoll底层原理*：看cyc 简述信号量机制 编写并发程序的强大而灵活的原语 并发与并行的区别 并发：一段时间 并行：同时 系统调用的全过程：参考17 僵尸进程、孤儿进程 孤儿进程 如果父进程先退出，子进程还没退出，那么子进程的父进程将变为init进程。（注：任何一个进程都必须有父进程）。 一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 僵尸进程 如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。 设置僵尸进程的目的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵尸状态）。 进程、线程切换的差别 线程上下文切换类似于进程上下文切换，进程切换将状态保存到进程控制块（PCB），线程对应线程控制 块（TCB）。线程切换地址空间不变，不需要切换当前使用的页表。 kill与kill -9的区别 默认情况下kill命令的参数为-15， 代表的信号为SIGTERM，这是告诉进程你需要被关闭，请自行停止运行并退出； 而kill -9代表的信号是SIGKILL，表示进程被终止，需要立即退出； 因此kill -9表示强制杀死该进程，这个信号不能被捕获也不能被忽略。 内存分配算法 最优匹配：遍历查找，性能较差。产生很多难以利用的小块 最差匹配：需要遍历、导致过量的碎片 首次匹配：速度优势、空闲块按内存地址排序 下次匹配：维护一个指针，指向上一个查找结束的位置，查找操作扩散到整个列表中去。 零拷贝原理","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://vivarisk.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"刷题-其他","slug":"刷题-其他","date":"2022-06-06T02:30:52.000Z","updated":"2022-08-18T17:09:15.068Z","comments":true,"path":"posts/48339ee4.html","link":"","permalink":"https://vivarisk.github.io/posts/48339ee4","excerpt":"记录一些刷题中需要注意的小问题","text":"记录一些刷题中需要注意的小问题 负数作被除数，-2 % 6 = -2，直接把负号加前面 （无符号右移）逻辑右移&gt;&gt;&gt; 机制转换，504，405 质数，204 Excel表问题，171，168 质因数，172","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://vivarisk.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"刷题-回溯","slug":"刷题：回溯","date":"2022-06-04T03:48:10.000Z","updated":"2022-06-06T01:20:41.332Z","comments":true,"path":"posts/b7ff5df1.html","link":"","permalink":"https://vivarisk.github.io/posts/b7ff5df1","excerpt":"回溯的题，这类题老是忘","text":"回溯的题，这类题老是忘 虽然不是回溯，力扣1091 最短、最优解这些用广度优先搜索，找到所有解的两个都行，但一般还是深度优先搜索更好写。 深度优先搜索 力扣695， 200， 547， 130 回溯 力扣17， 93， 79， 257，46，47，77，39，216，78，90，131 93题：复原IP地址 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); if(s.length() &lt; 4)&#123; return list; &#125; backtrack(s, new StringBuilder(), 0, list); return list; &#125; private void backtrack(String s, StringBuilder prefix, int num, List&lt;String&gt; list)&#123; if(num == 4 || s.length() == 0)&#123; if(num == 4 &amp;&amp; s.length() == 0)&#123; list.add(prefix.toString()); &#125; return; &#125; int n = s.length(); for(int i=0; i&lt;n &amp;&amp; i&lt;=2; ++i)&#123; if(i != 0 &amp;&amp; s.charAt(0) == &#x27;0&#x27;)&#123; return; &#125; String curr = s.substring(0, i+1); if(Integer.valueOf(curr) &lt;= 255)&#123; if(num != 0)&#123; curr = &quot;.&quot; + curr; &#125; prefix.append(curr); backtrack(s.substring(i+1), prefix, num+1, list); prefix.delete(prefix.length()-curr.length(), prefix.length()); &#125; &#125; &#125;&#125; 力扣257 123456789101112131415161718192021class Solution &#123; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); dfs(root, new StringBuilder(), list); return list; &#125; private void dfs(TreeNode root, StringBuilder path, List&lt;String&gt; list)&#123; path.append(root.val + &quot;&quot;); if(root.left == null &amp;&amp; root.right == null)&#123; list.add(path.toString()); return; &#125; if(root.left != null)&#123; dfs(root.left, new StringBuilder(path).append(&quot;-&gt;&quot;), list); &#125; if(root.right != null)&#123; dfs(root.right, new StringBuilder(path).append(&quot;-&gt;&quot;), list); &#125; &#125;&#125; 力扣47 12345678910111213for(int i=0; i&lt;n; ++i)&#123; if(!isVisited[i])&#123; isVisited[i] = true; path.add(nums[i]); backtrack(nums, list, path, isVisited); path.remove(path.size()-1); isVisited[i] = false; //111123, 回溯后，跳到最后一个1，for循环那还有一个++i，从2开始 while(i &lt; n-1 &amp;&amp; nums[i] == nums[i+1])&#123; ++i; &#125; &#125; &#125; 有顺序的，排列：for循环从0开始 没顺序的，组合：for循环从start开始，传参 ​ 力扣131 123456789101112131415161718192021222324252627282930313233class Solution &#123; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); List&lt;String&gt; path = new ArrayList&lt;&gt;(); backtrack(s, list, path); return list; &#125; private void backtrack(String s, List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; path)&#123; if(s.length() == 0)&#123; list.add(new ArrayList&lt;&gt;(path)); return; &#125; int n = s.length(); for(int i=0; i&lt;n; ++i)&#123; if(check(s, i))&#123; path.add(s.substring(0, i+1)); backtrack(s.substring(i+1), list, path); path.remove(path.size()-1); &#125; &#125; &#125; private boolean check(String s, int k)&#123; int i = 0, j = k; while(i &lt; j)&#123; if(s.charAt(i++) != s.charAt(j--))&#123; return false; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://vivarisk.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"回溯","slug":"回溯","permalink":"https://vivarisk.github.io/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"刷题-分治","slug":"刷题-分治","date":"2022-06-02T15:28:03.000Z","updated":"2022-06-06T01:22:45.982Z","comments":true,"path":"posts/756833e6.html","link":"","permalink":"https://vivarisk.github.io/posts/756833e6","excerpt":"关于分治的题，就记住吧","text":"关于分治的题，就记住吧 力扣241 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; //空间换时间，防止重复计算 private Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; diffWaysToCompute(String expression) &#123; if(map.containsKey(expression))&#123; return map.get(expression); &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int len = expression.length(); if(len == 0)&#123; list.add(0); return list; &#125; for(int i=0; i&lt;len; ++i)&#123; char c = expression.charAt(i); if(isOps(c))&#123; List&lt;Integer&gt; left = diffWaysToCompute(expression.substring(0, i)); List&lt;Integer&gt; right = diffWaysToCompute(expression.substring(i+1)); for(int l : left)&#123; for(int r : right)&#123; list.add(caculate(c, l, r)); &#125; &#125; &#125; &#125; if(list.size() == 0)&#123; list.add(Integer.valueOf(expression)); &#125; map.put(expression, list); return list; &#125; private boolean isOps(char c)&#123; return c == &#x27;+&#x27; || c == &#x27;-&#x27; || c == &#x27;*&#x27;; &#125; private int caculate(char c, int l, int r)&#123; if(c == &#x27;+&#x27;)&#123; return l + r; &#125;else if(c == &#x27;-&#x27;)&#123; return l - r; &#125;else&#123; return l * r; &#125; &#125;&#125; 力扣95 1234567891011121314151617181920212223242526272829303132class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; List&lt;TreeNode&gt;[][] dp = new ArrayList[n+1][n+1]; return generate(1, n, dp); &#125; private List&lt;TreeNode&gt; generate(int start, int end, List&lt;TreeNode&gt;[][] dp)&#123; List&lt;TreeNode&gt; list = new ArrayList&lt;&gt;(); //把特殊情况放前面，防止后面数组越界 if(start &gt; end)&#123; list.add(null); return list; &#125; if(dp[start][end] != null)&#123; return dp[start][end]; &#125; for(int i=start; i&lt;=end; ++i)&#123; List&lt;TreeNode&gt; left = generate(start, i-1, dp); List&lt;TreeNode&gt; right = generate(i+1, end, dp); for(TreeNode l : left)&#123; for(TreeNode r : right)&#123; TreeNode root = new TreeNode(i); root.left = l; root.right = r; list.add(root); &#125; &#125; &#125; dp[start][end] = list; return list; &#125;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://vivarisk.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"分治","slug":"分治","permalink":"https://vivarisk.github.io/tags/%E5%88%86%E6%B2%BB/"}]},{"title":"二分查找","slug":"二分查找","date":"2022-06-02T12:49:51.000Z","updated":"2022-06-02T16:22:40.938Z","comments":true,"path":"posts/e8eb0481.html","link":"","permalink":"https://vivarisk.github.io/posts/e8eb0481","excerpt":"二分查找总结，模板和相关题","text":"二分查找总结，模板和相关题 参考邓俊辉老师的《数据结构》56页 返回第一个大于target值的索引 123456789101112131415//始终满足[0, lo) &lt;= target, [hi, n) &gt; targetpublic int searchInsert(int[] nums, int target) &#123; int n = nums.length; int lo = 0, hi = n; while(lo &lt; hi)&#123; int mi = (lo + hi) / 2; if(nums[mi] &lt;= target)&#123; lo = mi + 1; &#125;else&#123; hi = mi; &#125; &#125; //最后lo == hi, 返回第一个大于target的索引，返回lo--为插入位置 return lo; &#125; 返回第一大于等于target值的索引 123456789101112131415//始终满足[0, lo) &lt; target, [hi, n) &gt;= targetpublic int searchInsert(int[] nums, int target) &#123; int n = nums.length; int lo = 0, hi = n; while(lo &lt; hi)&#123; int mi = (lo + hi) / 2; if(nums[mi] &lt; target)&#123; lo = mi + 1; &#125;else&#123; hi = mi; &#125; &#125; //最后lo == hi, 返回第一大于等于target的索引 return lo; &#125; 这两种情况应该够用了。右边界取n还是n-1看具体情况，返回第一个大于或大于等于的，下标可能在n（即所有数都比target小），[lo,hi]是所求的下标范围，能取到n那hi就定到n。 有时候mi需要向上取整，这就不记了 相关题： 540，记住 153，比较mi和hi","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://vivarisk.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二分","slug":"二分","permalink":"https://vivarisk.github.io/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"周记 | 5.9-5.15","slug":"周记-5-9-5-15","date":"2022-05-14T16:17:47.000Z","updated":"2022-06-02T16:20:02.937Z","comments":true,"path":"posts/8de1ee47.html","link":"","permalink":"https://vivarisk.github.io/posts/8de1ee47","excerpt":"随便写写","text":"随便写写博客里大多是心情低落时上来瞎写，其实我是一个很乐观的人，只不过心情不太好的时候才想起来这个博客。以后经常写着点，要努力啊，要不然每天记录自己的划水日常？五一之后这半个月好像什么都没干，不过跑通了那个qrtsc，汉化一下应该能应付毕业了嘿嘿。每周还要写点前端，我后悔之前说前端有意思了，调HTML能TM烦死人，好在下午把图片遍历弄好了。下周组会讲什么啊？每周的灵魂发问你不会真的要摆烂吧？！七月就要开始提前批了，抓紧时间学习，这半个月得把那个小说爬虫的项目看明白，放到简历里还不错。下个月看看能不能把6.824给做完，能做多少是多少吧。刷题的感觉越来越差了，这点让我很担忧每天都在自娱自乐，高强度网上冲浪，一抬头看见Ubuntu桌面就忍不住玩扫雷。米哈游你坏事做尽，大小号全歪保持好心情，规律作息，今天是这周第一次熬夜，每周晚睡一天不过分。下周赶紧把操作系统和Redis看完，好好刷题！！！","categories":[{"name":"片段","slug":"片段","permalink":"https://vivarisk.github.io/categories/%E7%89%87%E6%AE%B5/"}],"tags":[{"name":"周记","slug":"周记","permalink":"https://vivarisk.github.io/tags/%E5%91%A8%E8%AE%B0/"}]},{"title":"梦的现实延续","slug":"梦的现实延续","date":"2022-04-11T15:49:02.000Z","updated":"2022-06-02T16:26:44.950Z","comments":true,"path":"posts/459bb8ba.html","link":"","permalink":"https://vivarisk.github.io/posts/459bb8ba","excerpt":"一个奇怪的梦，醒后作。","text":"一个奇怪的梦，醒后作。 在我的价值观里，积极向上、努力奋斗是正确的。 没有朝着正确的方向努力会让我难过不安(这里需要一个更准确的词)。 努力奋斗了也并不会改变很多，1中观点会持续受阻，我渐渐躺平。 最后，这三个观点在可预见的时间里都不会改变，这些矛盾的想法、矛盾的内心想法与实际行动可能会让我在负面情绪中变得更消极但我也坚持了其他的我认为正确的，保持坦诚、保持善良等等。写下这些其实和我的日常生活出入很大，我平时只会想到3，只是偶尔比如现在才会想到1和2，所以绝大多时候我都很开心，就算现在也是，我接受这样一个矛盾的自己写下这些单纯地是怕我忘了1和2，因为我真的很少想着这些，前几天和朋友的聊天又无意中让我想到了这点。这是一种逃避吗，或许不是，但我的大脑自动忽略了它们，而在意识到后又感到一丝丝不安，当然这种感觉在变淡。遗忘可能导致我在未来情绪低落时找不到原因，当然这只能是原因之一或者压根不是现实中，一些形而下的，如中午吃什么、投哪家实习、多线程原理等等都占据着我的时间;而一些形而上的，看书看电影听歌等带来的艺术体验，发呆时大脑里的瞬时想法，又让我不觉时间流逝我的内心住着一个“白”，它没有任何价值判断，或许是完全的空白，这些年它逐渐长大，占据着我更多的时间空间两点睡的，六点多就醒了，现在却很清醒。梦里我在永夜中躲避一场大屠杀，奶奶出现了，她的音容笑貌真实可感，我要好好保护她。再一次见面让我感到幸福，在清醒时分写下这些。","categories":[{"name":"片段","slug":"片段","permalink":"https://vivarisk.github.io/categories/%E7%89%87%E6%AE%B5/"}],"tags":[{"name":"杂念","slug":"杂念","permalink":"https://vivarisk.github.io/tags/%E6%9D%82%E5%BF%B5/"}]},{"title":"周记 | 3.21-3.27","slug":"周记-3-21-3-27","date":"2022-03-26T16:13:54.000Z","updated":"2022-06-02T16:20:02.933Z","comments":true,"path":"posts/2d5bb144.html","link":"","permalink":"https://vivarisk.github.io/posts/2d5bb144","excerpt":"随便写写","text":"随便写写这一周的学习状态很差，总是不能专注，想想两年前用两个多月时间从头学四门专业课，真挺厉害的，现在的我精神状态、身体状态都一般如果说奶奶的离开是一种有无上的巨大落差，带来的是持久的消极情绪，昨天在听到了四年之前第一次听到的歌时，感受到的是无意中意识到自己的某些变化后的惊诧。四年来我确实变了很多，但具体是什么又很难具象捕捉，这变化如此显著却不可言说。重返袖珍时光的超级月亮，再次听到竟十分感动，当时还去红咖看了现场。变化开始于19年毕业时、还是20年入学后已不可考具体而持续的行动总是让人感到充实，刷题、MySQL、并发等等，要学的东西很多。虽然自己并不着急，但确实错过了很多机会，四月份要多投简历争取找到份实习，清明之前把所有的都过一遍吧没什么可写的了，昨天睡觉之前明明有很多想说的话。","categories":[{"name":"片段","slug":"片段","permalink":"https://vivarisk.github.io/categories/%E7%89%87%E6%AE%B5/"}],"tags":[{"name":"周记","slug":"周记","permalink":"https://vivarisk.github.io/tags/%E5%91%A8%E8%AE%B0/"}]},{"title":"Hello World!","slug":"Hello-World-0","date":"1997-02-22T12:00:00.000Z","updated":"2022-06-01T16:10:24.496Z","comments":true,"path":"posts/1c291ca3.html","link":"","permalink":"https://vivarisk.github.io/posts/1c291ca3","excerpt":"","text":"世界，你好！","categories":[{"name":"生活","slug":"生活","permalink":"https://vivarisk.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[]}],"categories":[{"name":"刷题","slug":"刷题","permalink":"https://vivarisk.github.io/categories/%E5%88%B7%E9%A2%98/"},{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"片段","slug":"片段","permalink":"https://vivarisk.github.io/categories/%E7%89%87%E6%AE%B5/"},{"name":"生活","slug":"生活","permalink":"https://vivarisk.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Java并发","slug":"Java并发","permalink":"https://vivarisk.github.io/tags/Java%E5%B9%B6%E5%8F%91/"},{"name":"MySQL","slug":"MySQL","permalink":"https://vivarisk.github.io/tags/MySQL/"},{"name":"刷题","slug":"刷题","permalink":"https://vivarisk.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://vivarisk.github.io/tags/%E5%89%91%E6%8C%87offer/"},{"name":"jvm","slug":"jvm","permalink":"https://vivarisk.github.io/tags/jvm/"},{"name":"二叉树","slug":"二叉树","permalink":"https://vivarisk.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"链表","slug":"链表","permalink":"https://vivarisk.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"操作系统","slug":"操作系统","permalink":"https://vivarisk.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"回溯","slug":"回溯","permalink":"https://vivarisk.github.io/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"分治","slug":"分治","permalink":"https://vivarisk.github.io/tags/%E5%88%86%E6%B2%BB/"},{"name":"二分","slug":"二分","permalink":"https://vivarisk.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"周记","slug":"周记","permalink":"https://vivarisk.github.io/tags/%E5%91%A8%E8%AE%B0/"},{"name":"杂念","slug":"杂念","permalink":"https://vivarisk.github.io/tags/%E6%9D%82%E5%BF%B5/"}]}