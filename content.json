{"meta":{"title":"航向树冠层","subtitle":"","description":"行行重行行","author":"廿二","url":"https://vivarisk.github.io","root":"/"},"pages":[{"title":"moments","date":"2023-01-30T09:16:24.624Z","updated":"2023-01-30T09:16:24.624Z","comments":false,"path":"moments/index.html","permalink":"https://vivarisk.github.io/moments/","excerpt":"","text":"new Artitalk({ appId: 'KokvLbNkMYbL88A2icbpJyFI-MdYXbMMI', // Your LeanCloud appId appKey: 'oxHJ0cu8xqxSU8efO7BwskP9', // Your LeanCloud appKey serverURL: 'https://api.huangsl.fun', pageSize: 5, //每页评论数量 atComment: 0, //评论功能的开关 0（关闭），1（开启） motion: 1, })"},{"title":"about","date":"2022-12-04T14:01:50.000Z","updated":"2023-07-12T18:50:20.533Z","comments":true,"path":"about/index.html","permalink":"https://vivarisk.github.io/about/","excerpt":"","text":"九零后，坐标北京，就职于银行软开 长年混迹网络，兴趣广泛，心得全无 📖📽️🎧⌨️"},{"title":"分类","date":"2022-05-29T06:15:27.000Z","updated":"2022-05-29T06:48:56.798Z","comments":false,"path":"categories/index.html","permalink":"https://vivarisk.github.io/categories/","excerpt":"","text":""},{"title":"标签","date":"2022-05-29T06:10:41.000Z","updated":"2022-05-29T06:49:28.456Z","comments":false,"path":"tags/index.html","permalink":"https://vivarisk.github.io/tags/","excerpt":"","text":""}],"posts":[{"title":"GitHub的ssh问题","slug":"GitHub的ssh问题","date":"2023-07-27T15:48:02.000Z","updated":"2023-07-27T16:10:08.277Z","comments":true,"path":"posts/a051eca0.html","link":"","permalink":"https://vivarisk.github.io/posts/a051eca0","excerpt":"","text":"最早可以说到三月份，当时在wsl上想编译一个pyqt项目，发现GitHub配置过ssh后仍然报错，不是网络的问题。当时时间紧，直接从win上复制过来了，在月初使用wsl又碰到了这个问题，而且在win上也是这样！有关ssh的内容后续要再深入学一下，暂时将解决时用到的两篇博客放在这，未来做补充 We updated our RSA SSH host key Sharing SSH keys between Windows and WSL 2 奇怪的是，push上去的commit信息居然是绑定邮箱的，虽然用的同一个ssh key，提交的却变成了我另一个GitHub账号","categories":[],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://vivarisk.github.io/tags/GitHub/"},{"name":"ssh","slug":"ssh","permalink":"https://vivarisk.github.io/tags/ssh/"}]},{"title":"毕业前后","slug":"毕业前后","date":"2023-07-09T15:28:39.000Z","updated":"2023-08-06T18:13:50.235Z","comments":true,"path":"posts/812f5981.html","link":"","permalink":"https://vivarisk.github.io/posts/812f5981","excerpt":"","text":"学校那条由南向北的路很短，也终于走到了最后。再见，我的学生时代 一年前的今天，我应该躺在刚租好的屋子里，知春东里。“知春”、“双榆树”是很美好的词语，它们变成了某种隐喻。如果春天路过那里，树木一定很是让人欣喜 一年过去了，我有什么变化吗？没有，这几年几乎没有转变过什么。未来的种种可能性铺展在眼前，我感到一丝非理性的迷信，总是觉得自己就要触碰到理想的生活了 一个月前收到了中行软开的签约通知，这对我再好不过了，银行稳定且工作强度没那么大，我可以把更多精力放在工作之外。匆匆而过的五个月，没有留下什么 二月初回到学校，开始写毕业论文。从零开始，又编又抄，偶尔应付下老师的无聊任务。构想创新点的过程十分不可复现，四处找文献，好在找到了还算说得过去的，将近一个月把初稿写完。系统上面没有花太多时间，拿现成的改了改。3月17交初稿，四月份没有抽到盲审和预答辩，5月31最后答辩，大体顺利 三月份开始考虑春招了，心里不太想准备，重新找工作的过程很厌烦，去字节也没什么不好，相信自己是能在互联网立足的。投了十来家，基本都是银行，四五月份做了很多笔试，也面了不少次。日子随着睡觉时的翻身不断流走，只在回忆时才发觉漫长。这段时间除非有事，都会躺到中午才下床，这种生活当然很不错，让我最印象深刻的可能是星穹铁道？五月底字节HR打来电话，问什么时候入职，只好说七月初。毕业论文签完字后，心想下周一定要开始学习了，几个月不写代码什么都忘了，就在那几天收到了中行的签约，自己好像总能在最后时刻改写比分 在公司附近租了房，一言难尽但就这么住着吧。前几年工资不高涨幅还可以，先攒攒房租和看牙的钱，可以更多地来说说毕业之后的事了 五一之前买了些素描用的纸笔工具，到现在还没拆封，等回到住的地方就开始每天学一点。这事在二零年初干过一次，不过画了几次就放弃了，直线都画不直。后面再买个midi键盘，乐理也要学一学。书准备了一些，小说有《托尔斯泰中短篇小说选》《地下室手记》《玩笑》，也准备看看康德的《未来形而上学导论》、再了解下黑格尔的思想，其实阅读倾向很明显，读大家的简短、概括的入门作品，很多想读的存在主义著作也是从批判黑格尔出发的，尽力去阅读吧。还有像《叶嘉莹说汉魏六朝诗》、《日常生活的心理分析》等书，当然还在平板上下了很多漫画，漫画似乎是连结当下与小时候的最快通路了。继续网上冲浪！音乐、电影也别落下 在编程上也更待提高，要加强基本功。面对工作上的屎山代码、复杂业务逻辑，确实没什么乐趣可言，但自己写点什么就很有意思了。先把《深入理解计算机系统》、《计算机程序的构造和解释》看了，相应的实验也尽力去写，争取把那几个经典课程的实验都做了。另一条是开发路线，开始先再熟悉下Java的开发过程，后面学学别的，elixir很有吸引力，PHP和Ruby也可以考虑，前端客户端桌面端就用flutter，不过也可以学学pyqt，对前端那一套深恶痛绝，万恶的npm。做点开源的东西，多更新博客 现在的文字多是流水账，阅读太少写得也少，未来要持续地阅读、写作。还有些别的想说，留到下次吧 School’s out，what did you expect？","categories":[{"name":"生活","slug":"生活","permalink":"https://vivarisk.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[]},{"title":"MIT-Missing-Semester笔记(四): 命令行环境","slug":"MIT-Missing-Semester笔记-四-命令行环境","date":"2023-07-08T16:00:13.000Z","updated":"2023-07-10T13:57:19.396Z","comments":true,"path":"posts/1f8a8f12.html","link":"","permalink":"https://vivarisk.github.io/posts/1f8a8f12","excerpt":"","text":"任务控制结束进程输入 Ctrl-C 时，shell 会发送一个SIGINT 信号到进程。SIGQUIT 信号，通过输入Ctrl-\\可以发送该信号。 #!/usr/bin/env python3 import signal, time def handler(signum, time): print(\"\\nI got a SIGINT, but I am not stopping\") signal.signal(signal.SIGINT, handler) i = 0 while True: time.sleep(.1) # \\n 换新行 \\r 刷新当前行 print(\"\\r{}\".format(i), end=\"\") i += 1 SIGTERM 则是一个更加通用的、也更加优雅地退出信号。为了发出这个信号我们需要使用 kill 命令, 它的语法是： kill -TERM &lt;PID&gt;。 暂停和后台执行进程Ctrl-Z 会让 shell 发送 SIGTSTP 信号 jobs列出当前终端会话的未完成任务，通过编号引用任务（直接123，或加%） kill命令只能通过%来操作任务，fg、bg可以直接123 jobs中+为最后第一个放入后台的任务，-为倒数第二个放入后台的任务 恢复暂停的工作fg、bg（前台、后台） pgrep检索pid $ python3 sigint.py 24^Z [1]+ Stopped python3 sigint.py $ fg 1 python3 sigint.py 43^Z [1]+ Stopped python3 sigint.py $ jobs [1]+ Stopped python3 sigint.py $ pgrep -l python 2824 python3 $ jobs [1]- Stopped python3 sigint.py [2]+ Stopped sleep 1000 $ kill -SIGHUP %1 [1]- Stopped python3 sigint.py $ jobs # 贴心地再显示一次 [1]- Hangup python3 sigint.py [2]+ Stopped sleep 1000 $ jobs [2]+ Stopped sleep 1000 命令中的 &amp; 后缀可以让命令在直接在后台运行，这使得可以直接在 shell 中继续做其他操作，不过它此时还是会使用 shell 的标准输出，这一点有时会比较恼人（这种情况可以使用 shell 重定向处理）。 -u Force the stdout and stderr streams to be unbuffered python3 -u直接重定向，不经过缓冲，否则重定向到其他文件可能不显示？ 关闭终端（会发送另外一个信号SIGHUP） nohup (一个用来忽略 SIGHUP 的封装) ，kill -SIGHUP对它无效 SIGKILL 是一个特殊的信号，不能被进程捕获并且它会马上结束该进程。传说中的9号，会留下孤儿进程 kill默认是15，SIGTERM 终端多路复用：tmuxtmux可以方便地在终端上操作多个窗口，通过三个层级管理：会话（session）、窗口（window）、面板（pane） 这有篇很好的教程A Quick and Easy Guide to tmux tmux的快捷键都是先按Ctrl+b，再按某功能键 session tmux开始一个新的会话 tmux new -s NAME以指定名称开始一个新会话 tmux ls列出当前会话 输入Ctrl+b d与当前会话分离 tmux attach -t NAME连接指定会话，a就行，[-t target-session] tmux kill-session -t NAME删除指定会话，Ctrl+d退出则直接删除 window：类似浏览器的标签，下边状态栏加*的是当前窗口 Ctrl+b c创建新窗口 Ctrl+b number跳转指定窗口 Ctrl+b ,重命名当前窗口 pane 可以将当前窗口分屏 Ctrl+b %竖直分屏 Ctrl+b &quot;水平分屏 Ctrl+b 上下左右在不同pane中跳转 Ctrl+b z最大/小化当前pane Ctrl+d关闭当前pane 确实很方便","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"MIT Missing Semester笔记（三）","slug":"MIT-Missing-Semester笔记（三）","date":"2023-03-23T15:27:48.000Z","updated":"2023-03-30T11:54:00.001Z","comments":true,"path":"posts/b726205c.html","link":"","permalink":"https://vivarisk.github.io/posts/b726205c","excerpt":"","text":"数据整理一些重要网址 在线正则表达式调试工具regex debugger 正则表达式教程 第四节课：数据整理，日志处理是典型的场景，比如journalctl | grep -i intel ssh myserver 'journalctl | grep sshd | grep \"Disconnected from\"' | less 将处理过程更多地放在服务器上，减少网络传输，less创建一个分页器 sed 是一个基于文本编辑器ed构建的”流编辑器” ，如： ssh myserver journalctl | grep sshd | grep \"Disconnected from\" | sed 's/.*Disconnected from //' s/REGEX/SUBSTITUTION/，其中regex为正则表达式，现查现用吧 . 除换行符之外的”任意单个字符” * 匹配前面字符零次或多次 + 匹配前面字符一次或多次 [abc] 匹配 a, b 和 c 中的任意一个 (RX1|RX2) 任何能够匹配RX1 或 RX2的结果 ^ 行首 $ 行尾 *和+默认是贪心的，sed不支持在它们后面增加?： # Jan 17 03:13:00 thesquareplanet.com sshd[2631]: Disconnected from # invalid user Disconnected from 46.97.239.16 port 55920 [preauth] # /.*Disconnected from /会匹配出 # 46.97.239.16 port 55920 [preauth] perl -pe 's/.*?Disconnected from //' # 可以只匹配到第一个 使用捕获组（capture groups）填充SUBSTITUTION部分，每个圆括号对应\\1、 \\2、\\3 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' 比较完整的处理 ssh myserver journalctl | grep sshd | grep \"Disconnected from\" | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' | sort | uniq -c | sort -nk1,1 | tail -n10 | awk '{print $2}' | paste -sd, uniq -c 会把连续出现的行折叠为一行并使用出现次数作为前缀， paste命令来合并行(-s)，并指定一个分隔符进行分割 (-d)。 对于awk，$0 表示整行的内容，$1 到 $n 为一行中的 n 个区域，区域的分割基于 awk 的域分隔符（默认是空格，可以通过-F来修改）。 # 统计所有以c开头，以e结尾，并且仅尝试过一次登录的用户 | awk '$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ { print $2 }' | wc -l # wc为word count xargs命令可以从标准输入和参数中读取所处理的内容，管道控制的是标准输入输出，一些命令如kill、rm只能读取参数，需要使用xargs将标准输出变为参数，参考了一篇知乎专栏 具体用法可参考这篇https://www.cnblogs.com/chenxiaomeng/p/16040498.html 课后习题参考答案 wsl并不是通过systemd进程启动的，在wsl中开启systemd参考这个","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Gridea试用","slug":"Gridea试用","date":"2023-01-30T03:34:12.000Z","updated":"2023-01-30T08:44:47.545Z","comments":true,"path":"posts/e3a44761.html","link":"","permalink":"https://vivarisk.github.io/posts/e3a44761","excerpt":"","text":"试用一下Gridea，之前了解过一点，用GUI界面简化了博客的搭建过程。主要参考官方文档快速上手 一点小问题：在一台电脑上用两个github账号有点问题，在虚拟机中试的。后面的截图是在ubuntu中，不影响 创建账号创建一个github账号 申请token申请一个token 在github主页点击右上角头像；左侧导航栏划到最后，点击Developer Settings；再点击Personal access tokens下的Tokens (classic) Note随便填，过期时间选永不过期就好，权限只勾repo就行 下方点击确认并复制token (token保存一下，只显示这一次)，如图： 新建仓库点击头像下拉选项框里的your repositories，再点击绿色New按钮。仓库名: 用户名.github.io, 其他都不用填 配置gridea安装gridea客户端，点击远程。分支填main，令牌填刚才的token 点检测远程连接试一试，在win上只有第一次成功了，在ubuntu上就没成功过。连不上也没事 使用在文章那里新建，写作界面比较简陋，远不如typora 右侧提供了一些实用功能，设置摘要、置顶文章、emoji表情、预览等 不建议插入太多图片，图片直接在仓库里，一是github访问速度问题，二是太占仓库空间 写完保存后，点左下角的同步。同步很玄学，目测走的https 具体见https://pica2pica.github.io/ 最后使用上较hexo简单一些，不需要命令行操作。本地和远程仓库的同步很玄学，可能是我网络的问题。总体使用体验不如hexo，后续有时间可以再摸索一下","categories":[{"name":"折腾","slug":"折腾","permalink":"https://vivarisk.github.io/categories/%E6%8A%98%E8%85%BE/"}],"tags":[{"name":"Gridea","slug":"Gridea","permalink":"https://vivarisk.github.io/tags/Gridea/"}]},{"title":"我的二〇二二","slug":"我的二〇二二","date":"2022-12-31T15:24:41.000Z","updated":"2023-03-30T11:48:18.704Z","comments":true,"path":"posts/9b29cd32.html","link":"","permalink":"https://vivarisk.github.io/posts/9b29cd32","excerpt":"","text":"回望这一年，仍有强烈的不真实感，整体十分混乱，也就匆匆动笔了 时间赋予了我们“一周年”，也终将把我们吞没。当UNIX时间戳自增到1672502400时2023年开始，时间的流逝没有任何偏好。但总该有所纪念，地球公转一周，四时晨昏交替，在魔幻的2022年岁末，写下自己的第一个年终总结 近几年简单地说：在挫败中寻找光亮 一个月过去了，今天是23年立春。回想起这一年多来，只能说自作自受，失望厌恶。认真努力吧，没什么可说的了","categories":[{"name":"生活","slug":"生活","permalink":"https://vivarisk.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"朝花夕拾","slug":"朝花夕拾","permalink":"https://vivarisk.github.io/tags/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"}]},{"title":"MIT-Missing-Semester笔记(二):Vim","slug":"MIT-Missing-Semester笔记-二-Vim","date":"2022-12-30T14:18:05.000Z","updated":"2023-03-22T08:25:12.700Z","comments":true,"path":"posts/1d744e80.html","link":"","permalink":"https://vivarisk.github.io/posts/1d744e80","excerpt":"","text":"关于Vim，不知道该怎么写，用得实在不多，零零散散写写。这篇以后用来记一记常用的Vim命令 参考WSL安装在win11上安装了WSL，简单用着体验很好 Vim的设计哲学：你大部分时间都在阅读浏览代码，不是在写代码 Vim分为下面几种模式： normal：HJKL分别对应左、下、上、右，浏览阅读 insert：按i进入，编辑代码 command：按：进入，执行一些命令（保存、退出、查找等） replace：替换文本 visual：用于选定范围文本复制 其他模式按esc回到normal模式 tab、buffer、windowVim里的比较重要的几个概念，tab像是浏览器打开的多个标签、buffer对应打开的一个文件、window是一个tab里打开的多个窗口。一个buffer可以对应多个window，可以同时看一个文件的不同部分 :sp :vsp [file] 垂直/水平打开新的窗口，ctrl+w+方向切换窗口 :tabnew 打开新标签 :tabn :tabN 切换下/上一个标签，Vim里用大写表示上一个的时候很多 其他 不小心ctrl+z将Vim置于后台，使用jobs命令显示所有后台命令，fg 1恢复序号为1的Vim进程 查找、替换 :/ 查找，用到再查 :s 替换，用到再查 Vim的接口本身就是一种编程语言，可以组合多个键，例如3dw删除后面的三个单词","categories":[],"tags":[{"name":"Vim","slug":"Vim","permalink":"https://vivarisk.github.io/tags/Vim/"}]},{"title":"秋招总结","slug":"秋招总结","date":"2022-12-30T05:59:46.000Z","updated":"2023-01-03T14:55:53.506Z","comments":true,"path":"posts/52dbc020.html","link":"","permalink":"https://vivarisk.github.io/posts/52dbc020","excerpt":"","text":"磨蹭到年底才动笔，秋招大概进行了两个半月，一共投递了80多家，互联网外企国企银行都投了，听说过的没听说过的都有。最后拿到了农行、滴滴、字节、分贝通、渤海银行的offer，决定去字节了。感觉选什么都会后悔，就不多想了。谁知道当下的选择会对未来有什么影响呢，那些其他选择的分叉道路会更好吗？ 也稍微提提实习，大概从寒假就准备找实习，一直到四月底才投出简历，七月初拿到了字节的实习。读了研以来走了不少弯路，不论科研还是找工作都有，这些也很难避免。很长时间在原地踏步，花费了很多时间技术上并没有什么提升 七月份刚去的时候，mentor跟我说小组里还有一个名额，到八月份的时候说让我两手准备。我也有心理预期，上半年来就有各种毁意向、毁offer、裁员的消息。实习到8月底，这两个月的实习还是收获很大的，虽然没干多少活，主要是熟悉了实际的开发流程，包括需求对接、开发调试、测试上线等等。部门里的同事都很好，工作氛围也不错，没能转正真的很可惜 九月一号回到学校，全力准备秋招。八月下旬投了几家，微软、亚马逊、华为、美团等，做了几个笔试。九月份主要面了美团、网易、京东、华为 美团：面了地图和配送部门，两个都是一面挂了，八股项目加做题，答得还凑合，可能还是比不过其他面试同学 网易：传媒事业群，大概负责网易新闻、网易公开课这一块。面得一般，一面问了一道很大的系统设计题：如何设计微信朋友圈，之前没准备过，胡言乱语一通，面试官人很好，一直在很认真地和我沟通；二面答得很差，一道二分的题没做好，跟面试官battle了十多分钟，后来发现还是我做错了&#x1f62d;。面试官说我的简历没什么可问的，也确实，不少东西写简历上了但我没准备，问了我也没答上来，十分减分，比如Kitex。11月份才给挂了，网易是真的磨叽 京东：京东科技，主要是负责消费券、智慧城市什么的。一面问了半个小时，没有做题，主要问的八股，答得还行；二面几乎什么都没问匆匆结束；HR面随便问了问。10月底挂了 华为：公共开发部，九月底的几天一面二面主管面。一面二面正常地问了问，主管面有点像HR面，大概聊了半个小时。一直到写下本文的年底，都没有消息，不过自己很早就不抱希望了 九月份还面了集度、龙湖、友塔游戏。集度一面挂，十月份集度给同学开得挺高；龙湖没太放在心上，十一月初好像才全部面完；友塔十月份挂了。重点提一下阿里，那段时间面了几次阿里，都是电话面然后秒挂，有天猫精灵和钉钉，会问一些八股和设计题，应该就是要求高，面试体验比较差 整个九月份都在笔试、面试中度过，忙碌中没有时间想什么。国庆的时候还是很有信心，京东网易华为我总能拿一个吧，后来才慢慢明白，对一些事没必要有过高期待。国庆躺了一周 十月份整体是越来越绝望的状态，面试越来越少，一个月没面几家：滴滴友塔荣耀，只有滴滴走完了流程。到十月下旬，基本对互联网不抱希望了，之前在截止日期之前投了不少银行，十月底银行扎堆笔试，那两天累死。那段时间没有面试，也没什么要学的，基本每天只是躺着，丧到了极点。那些天又重新开始玩饥荒了，算是苦中作乐 滴滴：国际化部门，负责南美的打车外卖业务。12号一面二面，13号三面。一面正常的八股加做题，不过出了道最大矩形的hard题，憋了半天做出来了。紧接着二面，问了一些实际开发中的问题，没答太好，做的题类似于排行榜的设计题，对Redis还是了解不够。三面也是正常问了问，这次直接问了如何设计微博的点赞排行榜，两面在同一个点被薄纱&#x1f62d;.11月17号电话给了意向，开得有点低，后面拒了 银行：10月21面了渤海银行，基础的八股，不过很多都没答好；11月10号那块问了boss上的渤海HR，她说过了在审批中，这才算是有了秋招的第一个意向，终于喘过来一口气；12月初才发体检通知，没再考虑。11月9号面了农行天研，面试问得很广，答得更差；11月15发了体检通知，很是高兴，这两个算是天津最好的开发岗位了；18号去做了体检，不过心率有点问题要求复检，被封在学校加上接了字节的offer，遗憾拒了 11月初，又赶上一波互联网的补录，面了快手、蚂蚁、字节、分贝通、完美世界和京东，不过都是相对边缘一些的部门了，不过无所谓，整整两个月没一个offer，有面试就还有希望。写到这有点累了，不再展开写了，快手二面挂；蚂蚁和阿里类似一面挂；分贝通走完了流程，面试官人很好，面完的下一周收到了意向，offer给得比较晚拒了，不过十分感谢豪哥内推；完美世界一面挂，其实答得挺好 字节：10月份面了TikTok直播，一面挂，答得一般；比较奇怪的是，在网站上更新的简历面试官一直看不到，实习那一块没加上。11月1号有HR打电话说之前的面试挂了，又转到了其他部门。4号一面，八股加做题，感觉答得一般；8号二面，答得还可以，题比较顺利；11号三面，答得也还行，那段时间又多看了看Redis，关于怎么设计排行榜和集群的知识，不过题做得有点磕磕绊绊，是这道寻找两个正序数组的中位数的hard题；14号通知四面，还是技术面，一般应该是HR面了，以为凉了，再面一轮是要继续刷人吗；16号四面问了一点设计题，问了一些实习的经历，最后简单做了一道题，最后还问了“你遇到的最大困难是什么”，也有点像HR面了，面试官是上海的，我以为给转到了上海的部门；之后两天HR打了两个电话，问了之前实习的部门、为什么实习时间这么短、意向工作地点、能不能提前去实习等；21号发了offer，流程很快，base北京、给的也很满意了，同天上午农行的老师跟我说要复检心电图，不能出学校短时间复检不了，这算是机缘巧合吗(不太合适这个词)? 接了字节的offer，没想太多，当然也想不出来什么 之后的面试都没参加了。月底学校疫情严重了，30号临走之前和同学寄了三方，秋招也彻底结束。回到家后，又收到了美团、京东、阿里的面试通知，没再继续。12月初得知字节盘点HC，大概11月下旬开始的，很多人的面试流程暂停了，我可能赶上了最后一波，又在脉脉上看到字节毁意向、开劝退价的帖子。很多时候我们在抱怨当前处境的时候，不知道的是，其实能走到现在已经足够得幸运。再提一句，少看脉脉！我面试的部门信息很少，在脉脉上能搜到的评价就那几条，都在疯狂劝退，我又能做什么，很累不想再去准备面试了，希望自己不会试用期被裁 专注当下，继续坚持，未来会走到何处？无所谓，都没关系︿(￣︶￣)︿","categories":[],"tags":[{"name":"秋招","slug":"秋招","permalink":"https://vivarisk.github.io/tags/%E7%A7%8B%E6%8B%9B/"}]},{"title":"新冠日记","slug":"新冠日记","date":"2022-12-22T06:00:33.000Z","updated":"2022-12-30T11:45:03.168Z","comments":true,"path":"posts/44ed0285.html","link":"","permalink":"https://vivarisk.github.io/posts/44ed0285","excerpt":"","text":"几个月来，新冠的各种信息一直充斥在网络上和生活周围，但我总觉得不会落到自己身上，直到岁末 11月29号学校出了阳性，当天学校就出了赶人的意思，申请了12月1日离校。回到家居家一周，一切照常。12月9号同学四人去了同学家吃饭，第二天有一个同学发烧了，抗原测了阳性，当时我还没什么感觉，幼稚地以为没那么容易感染。11日晚，嗓子有点不舒服也有点发热，感觉不妙&#x1f62a;。我们三个同时出了症状，看来是有个潜伏期 12月12日 自己感觉低烧，其实是因为我的手本来就比正常温度高，摸着额头好像只是低烧。上午大概是38.7，没敢和家里人说是前两天吃饭传上的，要被骂死哈哈。10号的时候姐姐一家过来吃饭，后面到了20号多他们也阳了，应该不是我传上的，可能10号的时候我还没多少传染性。下午就39度多了，吃了布洛芬和莲花清瘟。但是当天还不算太难受，只是头晕，还能玩原神&#x1f436; 12月13日 凌晨开始，头疼地无法入睡。12点半醒了，试图通过捂被子出汗来降温，但根本没效果，越捂越热几近爆炸。3点多，群里又聊了起来，大家都难受地不能入睡。体温40.4，给我烧迷糊了，找了个毛巾裹脑袋上降温，身上不能盖被，哪盖着被哪就巨快升温，只能稍微盖着点肚子。就这么混沌地熬到了六点，大概没有那么难受了，能正常盖被了，渐渐睡去 又似乎出现了小时候的那种感觉。小的时候，发烧时经常能看到一些类似蓝色血管的原始森林，很多血管在急速地变大变小，长大后不再出现。这次是会看到很多不同种类的形状，每次翻身都会打乱。到早上有所恢复后，每次翻身和盖被子都能把它们组合出一个规则形状。肯定是被那些微分几何、矢量化什么的pua所致，什么垃圾方向 这两天突然地想到了这首歌，在头脑混乱时让人有温吞振奋之感： 整个白天体温都在39度多，头疼异常，吃了莲花清瘟不起作用。基本上是一觉接着一觉，到了晚上七点多睡醒，体温38度多，出了些汗没那么难受了，和前一天差不多 12月14日 凌晨三点多醒了，明显感觉体温降了下来，一量36.7。正是阿根廷克罗地亚踢比赛的时候，想着支持莫德里奇，不过比分2 : 0了，遂睡去 当天正常，那几天嘴里发苦，吃什么都感觉有点咸，不知是新冠的原因还是饭菜确实做咸了。有点咳痰，不过就那一会，记不清是不是这一天了 12月15日 下午体温又升到38度多，头疼到晚上 12月16日 不难受了，体温好像是37度多，之后没再怎么量过 之后的几天有点咳嗽，可能是胸闷气短吧。家里没抗原一直没测，21号拿到抗原测了转阴 一直到月底，多少有一点点气短的感觉，就先不运动了(其实本来也不运动&#x1f436;)，恢复一个月看看","categories":[{"name":"生活","slug":"生活","permalink":"https://vivarisk.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"新冠","slug":"新冠","permalink":"https://vivarisk.github.io/tags/%E6%96%B0%E5%86%A0/"}]},{"title":"MIT-Missing-Semester笔记(一):Shell","slug":"MIT-Missing-Semester笔记","date":"2022-12-03T13:14:56.000Z","updated":"2022-12-28T14:09:10.980Z","comments":true,"path":"posts/f350bbc1.html","link":"","permalink":"https://vivarisk.github.io/posts/f350bbc1","excerpt":"","text":"MIT的课程：Missing Semester 介绍了Shell、vim、git等一些常用工具 检查Shell语法错误的在线网站ShellCheck Shell介绍一开始介绍了一些常用的命令，大部分之前使用过。 重定向符号&lt;、&gt;，追加用&gt;&gt; echo hello cd - #回到上一个目录 cat 2.txt &gt;&gt; 1.txt ls -l | tail -n3 #输出最后三行 man ls #多用man ls -ls #-l显示详细信息，-s显示文件占用块数block，后面可跟上目录 4 -rwxrw-r-- 1 hsl hsl 132 12月 3 20:26 test #文件占用块数、-文件d目录l链接 #权限：rwx读写执行权限，分别是拥有者、用户组、其他人 #文件数量、拥有者、用户组、时间、文件名 chmod u+x test curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=' ' -f2 \\转义字符，mkdir my\\ photo将空格转义，否则会建立两个目录 touch命令本意是修改时间戳，-a修改访问时间，-m改变修改时间，文件不存在时会默认新建 .sh文件开头#!/bin/sh是shebang，指示解释器运行环境 /sys目录下有很多系统设置，一切皆文件！ tee命令读取标准输入，写到标准输出和文件 还讲了find、grep、curl、cut命令，后面再看一下 变量、函数变量定义: foo=bar, 等号左右不能有空格，否则相当于调用foo命令，=和bar作参数。 foo=bar #单引号、双引号不同 echo \"$foo\" # prints bar echo '$foo' # prints $foo 写一个mcd命令 cat mcd.sh mcd () { mkdir -p $1 cd $1 } source mcd.sh $0 - Name of the script $1 to $9 - Arguments to the script. $1 is the first argument and so on. $@ - All the arguments $# - Number of arguments $? - Return code of the previous command $$$$ - Process identification number (PID) for the current script !! - Entire last command, including arguments. A common pattern is to execute a command only for it to fail due to missing permissions; you can quickly re-execute the command with sudo by doing sudo !! $_ - Last argument from the last command. If you are in an interactive shell, you can also quickly get this value by typing Esc followed by . or Alt+. 详细见：https://missing.csail.mit.edu/2020/shell-tools/ 替换command substitution for file in $(ls) process substitution diff &lt;(ls foo) &lt;(ls bar), &lt;( CMD ) 将执行 CMD 并将输出放在一个临时文件中，并将 &lt;() 替换为该文件的名称。 脚本举例举例（比较时尽量使用双方括号, why） #!/bin/bash echo \"Starting program at $(date)\" # Date will be substituted echo \"Running program $0 with $# arguments with pid $$\" for file in \"$@\"; do grep foobar \"$file\" &gt; /dev/null 2&gt; /dev/null # When pattern is not found, grep has exit status 1 # We redirect STDOUT and STDERR to a null register since we do not care about them if [[ $? -ne 0 ]]; then echo \"File $file does not have any foobar, adding one\" echo \"# foobar\" &gt;&gt; \"$file\" fi done 正则表达式 ? 匹配一个任意字符，* 匹配多个，{} 匹配花括号里所有 一个python脚本： #!/usr/bin/env python3 import sys for arg in reversed(sys.argv[1:]): print(arg) shebang写成这样移植性更好 函数和脚本 函数（平时一般叫命令？）必须和shell用同样的语言，脚本可以用任何语言，所以shebang很重要。 函数在读取其定义时加载一次。每次执行脚本时都会加载脚本。这使得函数的加载速度稍快一些，但是无论何时更改它们，都必须重新加载它们的定义。source命令吧 函数在当前的 shell 环境中执行，而脚本在它们自己的进程中执行。因此，函数可以修改环境变量，例如更改当前目录，而脚本不能。后面再看下export命令 查找# Find all directories named src find . -name src -type d # *匹配0个或多个目录，在文件那匹配0个或多个字符，？只能匹配一个 find . -path '*/test/*.py' -type f # Find all files modified in the last day find . -mtime -1 # Find all zip files with size in range 500k to 10M find . -size +500k -size -10M -name '*.tar.gz' # Find all python files where I used the requests library rg -t py 'import requests' # Find all files (including hidden files) without a shebang line rg -u --files-without-match \"^#!\" # Find all matches of foo and print the following 5 lines rg foo -A 5 # Print statistics of matches (# of matched lines and files ) rg --stats PATTERN # -R递归搜索目录，-n显示行号，-C显示邻近几行 grep -R -n -C 5 foobar . 其他类似grep的搜索工具 ack, ag和rg, 模糊匹配的fzf. 还有两个终端文件管理工具，nnn 和 ranger，看着挺炫酷，后面试一试 其他 tldr工具 一些命令不能从管道中读取数据，xargs可以将标准输入转化为参数。ls | xargs rm 课后习题 ls -lath --color=auto, -a显示隐藏文件，-t按修改时间降序排列，-h大小显示为多少M，多少k的形式。 执行marco时记录下当前目录，执行polo时回到之前记录的目录。 marco() { export MARCO=$(pwd) } polo() { cd \"$MARCO\" } 运行err.sh脚本, 记录其输出和错误日志, 输出其出错时的运行次数 err.sh #!/usr/bin/env bash n=$(( RANDOM % 100 )) if [[ n -eq 42 ]]; then echo \"Something went wrong at $(date)\" # &gt;2是将输出重定向到文件2, &amp;2才是标准错误 echo \"The error was using magic numbers\" 1&gt;&amp;2 exit 1 fi echo \"Everything went according to plan\" errTest.sh #!/usr/bin/env bash rm record.txt record2.txt t=1 ./err.sh &gt; ./record.txt 2&gt; ./record2.txt while [[ $? -eq 0 ]] do let t++ ./err.sh &gt;&gt; ./record.txt 2&gt;&gt; ./record2.txt done cat record.txt echo \"------\" cat record2.txt echo \"run counts: $t\" 搜索当前文件下的html文件并打包压缩，搜索出来的内容以换行符区分 ( 排除文件名中包含空格的情况 ) . # xargs -d 指定分隔符 find -name \"*.html\" | xargs -d '\\n' tar -czvf archieve.tar.gz 递归搜索当前文件夹中的文件，按文件最后修改时间逆序排列 # stat -c或--format格式化输出 Y是UNIX时间戳，y是可读时间，n文件名 # sort -n按数值比较 -r逆序 # cut -d分隔符 -f, --fields显示什么字段，从1开始，2-取第二个及以后 # head列出前几行，默认10 find . -type f | xargs -d '\\n' stat --format \"%Y %y %n\" | sort -nr | cut -d ' ' -f 2- | head -n 5 2022-12-28 20:46:34.869589528 +0800 ./22/33/1 3.html 2022-12-28 20:46:00.144839386 +0800 ./22/2 .html 2022-12-28 20:45:30.952572281 +0800 ./1.html 2022-12-27 23:13:16.676754571 +0800 ./record.txt 2022-12-27 23:13:16.676754571 +0800 ./record2.txt","categories":[],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://vivarisk.github.io/tags/Shell/"}]},{"title":"剑指offer专项突击版刷题总结","slug":"剑指offer专项突击版刷题总结","date":"2022-08-14T12:23:40.000Z","updated":"2022-12-22T12:51:37.806Z","comments":true,"path":"posts/b59e3d2c.html","link":"","permalink":"https://vivarisk.github.io/posts/b59e3d2c","excerpt":"题解总结","text":"题解总结 整数除法 最后是都要取绝对值计算，先把特殊情况考虑到了；模拟草稿纸上的除法运算，比如10000/23，在百位上写4，余数就不可能在百位上写值了，是一个依次向低位上写值的过程，二进制一样 class Solution { public int divide(int a, int b) { int ans = 0; if(b == Integer.MIN_VALUE){ return a == Integer.MIN_VALUE ? 1 : 0; } if(a == Integer.MIN_VALUE){ if(b == -1){ return Integer.MAX_VALUE; }else if(b == 1){ return Integer.MIN_VALUE; }else{ a += Math.abs(b); ans += 1; } } //对布尔值可以做位运算，结果还是布尔值 //int flag = (a &gt;&gt;&gt; 31) ^ (b &gt;&gt;&gt; 31) boolean flag = (a &gt; 0) ^ (b &gt; 0); a = Math.abs(a); b = Math.abs(b); for(int i=31; i&gt;=0; --i){ if((a &gt;&gt;&gt; i) &gt;= b){ ans += (1 &lt;&lt; i); a -= (b &lt;&lt; i); } } return flag ? -ans : ans; } }","categories":[{"name":"刷题","slug":"刷题","permalink":"https://vivarisk.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"并发学习","slug":"并发学习","date":"2022-06-16T13:35:45.000Z","updated":"2022-08-18T17:09:15.071Z","comments":true,"path":"posts/54cc7e1f.html","link":"","permalink":"https://vivarisk.github.io/posts/54cc7e1f","excerpt":"并发编程里的知识点","text":"并发编程里的知识点 volatile 是jvm提供的轻量级的同步机制：保证可见性、不保证原子性、禁止指令重排序 可见性：一个线程修改了主内存的值，要通知其他线程 synchronized 普通同步方法，锁是当前实例对象；静态同步方法，锁是当前类的Class对象；同步方法块：锁是括号里的对象。 同步代码：通过moniterenter、moniterexit 关联到到一个monitor对象，进入时设置Owner为当前线程，计数+1、退出-1。除了正常出口的 monitorexit，还在异常处理代码里插入了 monitorexit。 实例方法：隐式调用moniterenter、moniterexit（ACC_SYNCHRONIZED） 静态方法：隐式调用moniterenter、moniterexit 每一个对象都关联一个monitor，执行monitorenter时，会尝试获得对象对应的monitor的所有权，即尝试获得对象的锁。 在 HotSpot 虚拟机中，对象在内存中的布局分为三块区域：对象头，实例数据和对齐填充。对象头中包含两部分：MarkWord 和 类型指针。如果是数组对象的话，对象头还有一部分是存储数组的长度。多线程下 synchronized 的加锁就是对同一个对象的对象头中的 MarkWord 中的变量进行CAS操作。 epoch: 偏向时间戳后面再查查资料 如果当前锁已偏向其他线程||epoch值过期||class偏向模式关闭||获取偏向锁的过程中存在并发冲突，都会进入到InterpreterRuntime::monitorenter方法， 在该方法中会进行偏向锁撤销和升级。 只有匿名偏向的对象才能进入偏向锁模式。偏向锁是延时初始化的，默认是4000ms。初始化后会将所有加载的Klass的prototype header修改为匿名偏向样式。当创建一个对象时，会通过Klass的prototype_header来初始化该对象的对象头。简单的说，偏向锁初始化结束后，后续所有对象的对象头都为匿名偏向样式，在此之前创建的对象则为无锁状态。而对于无锁状态的锁对象，如果有竞争，会直接进入到轻量级锁。这也是为什么JVM启动前4秒对象会直接进入到轻量级锁的原因。 为什么需要延迟初始化？ JVM启动时必不可免会有大量sync的操作，而偏向锁并不是都有利。如果开启了偏向锁，会发生大量锁撤销和锁升级操作，大大降低JVM启动效率。 因此，我们可以明确地说，只有锁对象处于匿名偏向状态，线程才能拿到到我们通常意义上的偏向锁。而处于无锁状态的锁对象，只能进入到轻量级锁状态。 无锁状态只能升级为轻量级锁，匿名偏向状态才能进入到偏向锁 3.偏向锁并不都有利，其适用于单个线程重入的场景，原因为：偏向锁的撤销需要进入safepoint，开销较大。需要进入safepoint是由于，偏向锁的撤销需要对锁对象的lock record进行操作，而lock record要到每个线程的栈帧中遍历寻找。在非safepoint，栈帧是动态的，会引入更多的问题。目前看来，偏向锁存在的价值是为历史遗留的Collection类如Vector和HashTable等做优化，迟早药丸。Java 15中默认不开启。4.执行Object类的hashcode方法，偏向锁撤销并且锁会膨胀为轻量级锁或者重量锁。执行Object类的wait/notify/notifyall方法，偏向锁撤销并膨胀成重量级锁。5.轻量级锁适用于两个线程的交替执行场景：线程A进入轻量级锁，退出同步代码块并释放锁，会将锁对象恢复为无锁状态；线程B再进入锁，发现为无锁状态，会cas尝试获取该锁对象的轻量级锁。如果有竞争，则直接膨胀为重量级锁，没有自旋操作，详情看10。 Java锁与线程的那些事 这篇写得太好了，后面一定好好看看 volatile 原理：首先我们要了解线程在java内存里面执行的原理，每个线程获取到CPU的时钟区间之后，会从ready状态-&gt;running状态，在x86处理器下，每个线程在执行的时候，不会直接读取主内存，而是会在每个CPU的高速缓存里面读取数据，每次CPU在执行线程的时候，会将需要的数据从主内存读取到高速缓存中，而在多核CPU的情况下，如果一个CPU进行了计算，然而其他CPU里面的缓存数据还是旧的，那么就会导致计算出错（脏数据）的情况，为了避免这种情况，保证多个CPU之间的高速缓存是一致的，OS里面会有一个缓存一致性协议，volatile就是通过OS的缓存一致性策略来保持共享变量在多个线程之间的可见性。 缓存一致性：每个CPU会在总线上面有一个嗅探器，当一个CPU将高速缓存的内容写到主内存时候，每个CPU会去查看自己缓存里面的缓存行对应的内存地址的值是否被修改了，如果发现被修改了，会将缓存里面的数据设为无效，当处理器要对自身告诉缓存里面的这个数据进行修改，会强制重新从系统主内存读取数据进来之后再去修改（详细可参考intel的mesi协议：http://blog.csdn.net/muxiqingyang/article/details/6615199）。 局限性：由于volatile只是保持了共享变量的可见性，当多线程并发的时候，多个线程分别分配到CPU中，比如执行x++操作，我们都知道实际上x++ &lt;=&gt; x=x+1，那么x++不是一个原子操作而是一个两步的操作，当对共享变量使用volatile之后，在CPU1里面一个线程进行了+1操作，并将数据写回到主内存时候，根据缓存一致性策略，会将各个其他CPU高速缓存里面的缓存行设为无效，然而当此时另一个线程已经完成了从CPU告诉缓存段读取数据到变量的操作，此时变量的值已经在jvm的栈里面，虽然CPU2里面的缓存段已经失效了，但是在并发情况下，还是可能会出现数据丢失的情况，不能保证并发情况下对共享变量的访问。 使用场景： (1)对变量的写操作不依赖于当前值。 (2)该变量没有包含在具有其他变量的不变式中。 实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。 所以可以看出，实际上volatile作为只保证可见性的并发策略，只适用于独立的不依赖于当前值的变量，一般来说是只能适合于Boolean变量并且是独立的与其他互不相关的Boolean变量，当然自从jdk1.5之后，java引进了CAS机制来保证volatile的原子性。 volatile适合一个线程写，多个线程读 CAS比synchronized快 （1）CAS是一个硬件指令，通过硬件层次去保证原子性，比synchronized在jvm层次通过一个监听者作为锁来保证原子性更快 （2）OS里面的LOCK指令分为两种锁： 1.一种是总线锁，当LOCK指令锁住的是总线的时候，那么每一刻只有一个CPU能够访问到总线，那样就保证了原子性的操作，但是由于同一时刻只有一个CPU，就是单线程能访问到总线，但因为是硬件上层次的锁，所以性能还是优于synchronized； 2.另外一种是缓存锁，当cmpxchg指令要操作的内存能完全保存在一个缓存行里面的时候，CPU高速缓存里面也完全缓存了这个缓存行，当要对缓存行进行写操作之前，根据缓存一致性策略会将缓存行修改为MESI里面的E（Exclusive）状态，当缓存行处于这个状态的时候，其他CPU里面不能访问这个缓存行的数据，就是说此时这个缓存行是被锁定独占的，那么CAS就会就直接执行cmpxchg指令而不去发出LOCK指令到总线，因为是独占的占有这个缓存行，所以也是一个原子性的操作。而因为缓存行层次上的锁更具有并发性和锁的时间更短，所以性能上比synchronized要快的多。 所以当同步锁的性能还不是系统性能瓶颈的时候，可以先考虑使用同步锁synchronized和lock，但是当同步锁的性能已经是系统瓶颈，那就要开始考虑使用CAS+volatile的非阻塞乐观锁的方式来降低同步锁带来的阻塞性能的问题 https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/ https://www.jianshu.com/p/cd4744d799e4 https://www.cnblogs.com/wuqinglong/p/9945618.html","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://vivarisk.github.io/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"MySQL笔记","slug":"MySQL笔记","date":"2022-06-16T10:56:24.000Z","updated":"2022-08-18T17:09:15.062Z","comments":true,"path":"posts/fd5f561d.html","link":"","permalink":"https://vivarisk.github.io/posts/fd5f561d","excerpt":"MySQL学习过程中的一些知识点","text":"MySQL学习过程中的一些知识点 全部使用长连接，内存占用问题 1.定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后， 断开连接，之后要查询再重连。 2.如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执 行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权 限验证，但是会将连接恢复到刚刚创建完时的状态。 为什么不建议使用查询缓存 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清 空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新 压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很 长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。 Write-Ahead Logging: 先写日志，再写磁盘 redolog只是完成了prepare, 而binlog又失败，那么事务本身会回滚 1 prepare阶段 2 写binlog 3 commit 当在2之前崩溃时 重启恢复：后发现没有commit，回滚。备份恢复：没有binlog 。 一致 当在3之前崩溃 重启恢复：虽没有commit，但满足prepare和binlog完整，所以重启后会自动commit。备份：有binlog. 一致 一天一备份、一周一备份 RTO（恢复目标时间）好处是“最长恢复时间”更短。 在一天一备的模式里，最坏情况下需要应用一天的 binlog。当然这个是有成本的，因为更频繁全量备份需要消耗更多存储空间，所以这个 RTO 是成 本换来的，就需要你根据业务重要性来评估了。","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://vivarisk.github.io/tags/MySQL/"}]},{"title":"剑指offer刷题","slug":"剑指offer刷题","date":"2022-06-16T02:53:07.000Z","updated":"2022-11-07T05:51:48.016Z","comments":true,"path":"posts/4f6f4f56.html","link":"","permalink":"https://vivarisk.github.io/posts/4f6f4f56","excerpt":"剑指offer从头刷一遍","text":"剑指offer从头刷一遍 剑指03//数组中重复的数字，当一个数和其下标不对应时，就把它交换到正确的位置， //如果正确的位置有一个同样的值（就找到重复的了）， //while中每次都会有一个值处在正确的位置，时间复杂度O(n) class Solution { public int findRepeatNumber(int[] nums) { int n = nums.length; for(int i=0; i&lt;n; ++i){ while(nums[i] != i){ if(nums[nums[i]] == nums[i]){ return nums[i]; } swap(nums, i, nums[i]); } } return -1; } } 剑指07//根节点以前序遍历下标为准，子树范围是中序遍历的 class Solution { private int[] preorder; private Map&lt;Integer, Integer&gt; inorderMap = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] preorder, int[] inorder) { this.preorder = preorder; int n = inorder.length; for(int i=0; i&lt;n; ++i){ inorderMap.put(inorder[i], i); } return recur(0, 0, n-1); } private TreeNode recur(int preRootIdx, int inLeftIdx, int inRightIdx){ if(inLeftIdx &gt; inRightIdx){ return null; } int preRootVal = preorder[preRootIdx]; int inRootIdx = inorderMap.get(preRootVal); TreeNode root = new TreeNode(preRootVal); root.left = recur(preRootIdx+1, inLeftIdx, inRootIdx-1); root.right = recur(preRootIdx + inRootIdx - inLeftIdx + 1, inRootIdx + 1, inRightIdx); return root; } } 剑指09：用两个栈实现队列。stack2只push，弹出时当stack1非空时弹出stack1，否则将stack2中所有元素出栈并入栈stack1，stack1再出栈。 154 //旋转数组最小值，有重复 //比较mi和hi，相同时hi左移 class Solution { public int findMin(int[] nums) { int lo = 0, hi = nums.length - 1; while(lo &lt; hi) { int mi = lo + (hi - lo) / 2; if(nums[mi] &lt; nums[hi]){ hi = mi; }else if(nums[mi] &gt; nums[hi]){ lo = mi + 1; }else{ hi = hi - 1; } } return nums[lo]; } } 79 回溯的题 343整数拆分//如果一个因子大于4，拆成2和n-2一定更大 //4，拆成2+2 class Solution { public int integerBreak(int n) { if(n &lt; 4){ return n - 1; } int a = n / 3, remainder = n % 3; if(remainder == 0) return (int)Math.pow(3, a); if(remainder == 1) return (int)Math.pow(3, a-1) * 4; return (int)Math.pow(3, a) * 2; } } 二进制中1的个数//n &amp; (n-1)会消掉最低位的1 class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { int count = 0; while(n != 0){ n = n &amp; (n - 1); ++count; } return count; } } 快速幂class Solution { public double myPow(double x, int n) { double ans = 1.0; long b = n; if(b &lt; 0){ b = -b; x = 1/x; } while(b != 0){ if((b &amp; 1) == 1){ ans *= x; } x *= x; b &gt;&gt;= 1; } return ans; } } 大数打印 //记住就完事了 class Solution { private StringBuilder curr = new StringBuilder(); private int[] ans; private int count = 0; public int[] printNumbers(int n) { ans = new int[(int)Math.pow(10, n) - 1]; for(int i=1; i&lt;=n; ++i){ dfs(0, i); } return ans; } private void dfs(int x, int len) { if(x == len){ ans[count++] = Integer.parseInt(curr.toString()); return; } int start = (x == 0 ? 1 : 0); for(int i=start; i&lt;10; ++i){ curr.append(i); dfs(x+1, len); curr.deleteCharAt(curr.length()-1); } } } 正则表达式 class Solution { public boolean isMatch(String s, String p) { int m = s.length(), n = p.length(); boolean[][] dp = new boolean[m+1][n+1]; //s,p都为空默认匹配 dp[0][0] = true; //s为空, p为.*也能匹配 for(int j = 1; j&lt;=n; ++j){ if(p.charAt(j-1) == '*'){ dp[0][j] = dp[0][j-2]; } } for(int j=1; j&lt;=n; ++j){ for(int i=1; i&lt;=m; ++i){ if(p.charAt(j-1) == '*'){ if(s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == '.'){ //匹配0次或多次 dp[i][j] = dp[i][j-2] || dp[i-1][j]; }else{ //只能匹配0次 dp[i][j] = dp[i][j-2]; } }else{ if(s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == '.'){ dp[i][j] = dp[i-1][j-1]; } } } } return dp[m][n]; } }","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://vivarisk.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://vivarisk.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"jvm总结","slug":"jvm总结","date":"2022-06-12T03:24:47.000Z","updated":"2022-12-02T09:37:31.930Z","comments":true,"path":"posts/d6085898.html","link":"","permalink":"https://vivarisk.github.io/posts/d6085898","excerpt":"jvm学习中的一些知识点","text":"jvm学习中的一些知识点 Java内存区域每一个实例对象的对象头，都有一个指针指向类对象（Class对象，在堆中，其中有类的静态变量），Class对象作为访问方法区中的类型数据的外部接口。 垃圾回收","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://vivarisk.github.io/tags/jvm/"}]},{"title":"刷题-二叉树","slug":"刷题-二叉树","date":"2022-06-09T05:01:03.000Z","updated":"2022-08-18T17:09:15.067Z","comments":true,"path":"posts/55daf129.html","link":"","permalink":"https://vivarisk.github.io/posts/55daf129","excerpt":"二叉树的题，递归要熟悉","text":"二叉树的题，递归要熟悉 543，617，112 力扣437 class Solution { public int pathSum(TreeNode root, int targetSum) { Map&lt;Long, Integer&gt; map = new HashMap&lt;&gt;(); map.put(0L, 1); return recur(root, targetSum, map, 0L); } private int recur(TreeNode root, int target, Map&lt;Long, Integer&gt; map, Long curr){ if(root == null){ return 0; } curr += root.val; int count = map.getOrDefault(curr - target, 0); map.put(curr, map.getOrDefault(curr, 0) + 1); //map存储当前节点和祖先节点的前缀和，传给子节点 count += recur(root.left, target, map, curr); count += recur(root.right, target, map, curr); //路径是向下的，回溯时要删除当前节点对应的前缀和 map.put(curr, map.get(curr) - 1); return count; } } 路径问题：求数量可以用前缀和，求所有结果还是dfs 109，用全局变量","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://vivarisk.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://vivarisk.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"刷题-链表","slug":"刷题-链表","date":"2022-06-08T07:07:53.000Z","updated":"2022-08-18T17:09:15.069Z","comments":true,"path":"posts/6db30a46.html","link":"","permalink":"https://vivarisk.github.io/posts/6db30a46","excerpt":"链表的题","text":"链表的题 涉及到头节点的题，最好设一个dummy节点 24，445，234","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://vivarisk.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"链表","slug":"链表","permalink":"https://vivarisk.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"操作系统总结","slug":"操作系统总结","date":"2022-06-06T08:00:11.000Z","updated":"2023-01-06T09:44:43.467Z","comments":true,"path":"posts/25519ab6.html","link":"","permalink":"https://vivarisk.github.io/posts/25519ab6","excerpt":"操作系统知识点总结","text":"操作系统知识点总结 进程、线程、协程的区别 进程指运行中的程序。一般我们希望同时运行多个程序，操作系统通过虚拟化CPU来提供这个假象，让一个进程只运行一个时间片，然后切换其他进程。进程是分配资源的单位，进程的机器状态（machine state，进程在运行时可以读取或更新的内容）：它的内存（地址空间）、寄存器。 线程是为单个进程提供的抽象，经典观点：一个程序只有一个执行点（一个PC），多线程程序有多个执行点（多个程序计数器，分别用于取指和执行），每个线程有一个程序计数器、一组寄存器。线程是调度的基本单位，把一个进程的资源分配和执行调度分开。线程间共享地址空间，能够访问相同的数据。 ​ (线程上下文切换类似于进程上下文切换，进程切换将状态保存到进程控制块（PCB），线程对应线程控制块（TCB）。线程切换地址空间不变，不需要切换当前使用的页表。） java线程的实现基于内核线程（实际上是内核进程的一个接口：轻量级进程），各种线程操作、切换都要进行系统调用，代价较高，需要在用户态、内核态切换，同时也会消耗一定内核资源，容纳的线程数量有限。1：1 ​ 协程：用户线程，1：N。用户线程的建立、同步、销毁和调度完全在用户态中完成。操作快、消耗低，但 实现上比较复杂，需要应用层实现的内容（调用栈、调度器）特别多。 ​ HotSpot中，java线程直接映射到操作系统原生线程，抢占式调度，调度最终由操作系统说了算。 进程间通信方式 每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication） https://www.jianshu.com/p/c1015f5ffa74 1.匿名管道 2.有名管道 3.信号 4.消息队列（内核中） 5.共享内存：多个进程共享一段内存 6.信号量：用于进程同步 7.套接字 3.死锁的产生条件和解决方案 多个进程可以竞争有限数量的资源。当一个进程申请资源时，如果这时没有可用资源，那么这个进程进入等待状态。有时，如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变状态。这种情况称为 死锁。 互斥：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。 占有并等待：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。 非抢占：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。 循环等待：有一组等待进程 &#123;P0, P1,..., Pn&#125;， P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，……，Pn-1 等待的资源被 Pn 占有，Pn 等待的资源被 P0 占有。 解决死锁的方法 预防 是采用某种策略，限制并发进程对资源的请求，从而使得死锁的必要条件在系统执行的任何时间上都不满足。 1.静态分配策略：破坏第二个条件。一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。降低了资源利用率 2.层次分配策略：破坏第二个条件。在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它才能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的 死锁避免 当一个进程申请使用资源的时候，银行家算法 通过先 试探 分配给该进程资源，然后通过 安全性算法 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 真的分配资源给该进程。需要花费较多的时间。 死锁检测 如果进程-资源分配图中无环路，则此时系统没有发生死锁 如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁。 如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁。如果能在进程-资源分配图中找出一个 既不阻塞又非独立的进程 ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 消除所有的边 ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 拓扑排序) 死锁解除 立即结束所有进程的执行，重新启动操作系统 ：这种方法简单，但以前所在的工作全部作废，损失很大。 撤销涉及死锁的所有进程，解除死锁后继续运行 ：这种方法能彻底打破死锁的循环等待条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。 逐个撤销涉及死锁的进程，回收其资源直至死锁解除。 抢占资源 ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。 4.虚拟内存及其作用介绍 操作系统提供了一个易用的物理内存抽象：地址空间。一个进程的地址空间包含运行程序的所有内存状态、代码、栈和堆。 为什么要有虚拟内存：方便和易用性、支持多个并发进程 3个目标： 1.透明：程序感觉不到内存被虚拟化的事实，好像拥有自己的内存。操作系统和硬件完成了所有的工作。 2.效率：时间上不会使程序执行得更慢，空间上不太需要额外的内存。依靠硬件支持。 3.保护：一个进程不会影响其他进程或操作系统的内存内容（它的地址空间之外的内容），对进程之间提供隔离。 5.线程间通信方式 互斥量(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。 信号量(Semphares) ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。 事件(Event) :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。 6.进程调度算法 1.先进先出FIFO 2.最短任务优先：非抢占式 3.最短完成时间优先：抢占式 4.时间片轮转 5.多级反馈队列 规则 1：如果 A 的优先级 &gt; B 的优先级，运行 A（不运行 B）。 规则 2：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B。 规则 3：工作进入系统时，放在最高优先级（最上层队列）。 规则 4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）。 规则 5：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。 6.比例份额：确保每个工作获得一定比例的CPU时间。彩票份额、行程值 用户态内核态区别 用户空间:指的就是用户可以操作和访问的空间，这个空间通常存放我们用户自己写的数据等等；而内核空间则是系统内核来操作的一块空间，这块空间里面存放系统内核的函数、接口等。不管对于Linux还是Windows， 他们都具有自己用户空间和内核空间。当一个程序运行时，如果它是在用户空间下执行，我们把此时运行得程序的这种状态成为用户态，而当这段程序执行在内核的空间执行时，这种状态称为内核态。 用户模式（user mode）。在用户模式下运行的代码会受到限制。例如，在用户模式下运行时，进程不能发出 I/O 请求。这 样做会导致处理器引发异常，操作系统可能会终止进程。与用户模式不同的内核模式（kernel mode），操作系统（或内核）就以这种模式运行。 在此模式下，运行的代码可以做它喜欢的事，包括特权操作，如发出 I/O 请求和执行所有类 型的受限指令。 作用1：安全执行受限制的指令 作用2：实现进程切换 进程的状态 1.创建 2.就绪 3.运行 4.阻塞 5.结束 如何实现进程间共享内存？ 为了支持共享，需要一些额外的硬件支持，这就是保护位（protection bit）。基本为每个段增加了几个位，标识程序是否能够读写该段，或执行其中的代码。通过将代码段标记为只 读，同样的代码可以被多个进程共享，而不用担心破坏隔离。虽然每个进程都认为自己独占 这块内存，但操作系统秘密地共享了内存，进程不能修改这些内存，所以假象得以保持。 使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。 为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。 由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。 类型 原理 易失性 mmap 利用文件(open)映射共享内存区域 会保存在磁盘上，不会丢失 Posix shared memory 利用/dev/shm文件系统(mmap)映射共享内存区域 随内核持续，内核自举后会丢失 SystemV shared memory 利用/dev/shm文件系统(shmat)映射共享内存区域 随内核持续，内核自举后会丢失 线程状态 java线程状态： 1.新建：创建后未启动 2.运行：包括操作系统中的Running和Ready 3.无限期等待（wait）：线程主动等待 4.限期等待：带时间的wait、join等 5.阻塞：等待获得一个排他锁 6.结束（terminated） 内存泄露概念与产生原因与影响 为内存泄露（memory leak），如果忘记释放内存，就会发生。系统中实际存在两级内存管理。 第一级是由操作系统执行的内存管理，操作系统在进程运行时将内存交给进程，并在进程退出（或以其他方式结束）时将其回收。第二级管理在每个进程中，例如在调用 malloc()和 free()时，在堆内管理。 即使你没有调用 free()（并因此泄露了堆中的内存），操作系统也会在程序结束运行时，收回进程的所有 内存（包括用于代码、栈，以及相关堆的内存页）。无论地址空间中堆的状态如何，操作系统都会在进程终止时收回所有这些页面，从而确保即使没有释放内存，也不会丢失内存。 因此，对于短时间运行的程序，泄露内存通常不会导致任何操作问题（尽管它可能被认为是不好的形式）。如果你编写一个长期运行的服务器（例如 Web 服务器或数据库管理系统，它永远不会退出），泄露内存就是很大的问题，最终会导致应用程序在内存不足时崩溃。 如何查看端口占用 netstat 查看进程内存与CPU占用情况 top 内存溢出的产生原因与相关处理 没有分配足够的内存，有时称为缓冲区溢出。 在某些情况下，这是无害的，可能会覆盖不再使用的变量。在某些情况下，这些溢出可 能具有令人难以置信的危害，实实上是系统中许多安全漏洞的来源。在其他情况下， malloc 库总是分配一些额外的空间，因此你的程序实实上不会在其他某个变量的值上涂写， 并且工作得很好。还有一些情况下，该程序确实会发生故障和崩溃。 操作系统分页、分段、TLB 操作系统需要把进程的地址空间映射到物理内存，如果完全照搬，将会有大量的空间浪费。具体怎么映射，就有了分段、分页。 分段：需要多对基址、界限寄存器。会有外部碎片 分页：将地址空间划分为固定的大小。需要额外的一次内存访问。 TLB：用来解决分页中额外的一次内存访问 页表太大 段页式 多级页表：与使用的地址空间成比例，更紧凑 请求分页、请求分段：在硬盘上开辟一片空间用于物理页的移入和移出：交换空间。书P166 正在运行的进程生成虚拟内存引用（用于获取指令 或访问数据），在这种情况下，硬件将其转换为物理地址，再从内存中获取所需数据。 硬件首先从虚拟地址获得 VPN，检查 TLB 是否匹配（TLB 命中），如果命中，则获得最终的物理地址并从内存中取回。这希望是常见情形，因为它很快（不需要额外的内存访问）。 如果在 TLB 中找不到 VPN（即 TLB 未命中），则硬件在内存中查找页表（使用页表基 址寄存器），并使用 VPN 查找该页的页表项（PTE）作为索引。如果页有效且存在于物理内存中，则硬件从 PTE 中获得 PFN，将其插入 TLB，并重试该指令，这次产生 TLB 命中。到现在为止还挺好。 但是，如果希望允许页交换到硬盘，必须添加更多的机制。具体来说，当硬件在 PTE 中查找时，可能发现页不在物理内存中。硬件（或操作系统，在软件管理 TLB 时）判断是否在内存中的方法，是通过页表项中的一条新信息，即存在位（present bit）。如果存在位设 置为 1，则表示该页存在于物理内存中，并且所有内容都如上所述进行。如果存在位设置为 零，则页不在内存中，而在硬盘上。访问不在物理内存中的页，这种行为通常被称为页错 误（page fault）。 如果一个页不存在，它已被交换到硬盘，在处理页错误的时候，操作系统需要将该页 交换到内存中。那么，问题来了：操作系统如何知道所需的页在哪儿？在许多系统中，页 表是存储这些信息最自然的地方。因此，操作系统可以用 PTE 中的某些位来存储硬盘地址， 这些位通常用来存储像页的 PFN 这样的数据。当操作系统接收到页错误时，它会在 PTE 中 查找地址，并将请求发送到硬盘，将页读取到内存中。 页面置换算法 最优替换策略：只用来做对比 先入先出 随机 LRU、LFU：P180，完美LRU实现代价较高 时钟算法：近似LRU 用户态如何切换到内核态 每个进程都有一个内核栈，用来保存进程的上下文。P40 进程切换的具体过程：P43，上下文的保存/恢复有两种。 epoll底层原理*：看cyc 简述信号量机制 编写并发程序的强大而灵活的原语 并发与并行的区别 并发：一段时间 并行：同时 系统调用的全过程：参考17 僵尸进程、孤儿进程 孤儿进程 如果父进程先退出，子进程还没退出，那么子进程的父进程将变为init进程。（注：任何一个进程都必须有父进程）。 一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 僵尸进程 如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。 设置僵尸进程的目的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵尸状态）。 进程、线程切换的差别 线程上下文切换类似于进程上下文切换，进程切换将状态保存到进程控制块（PCB），线程对应线程控制 块（TCB）。线程切换地址空间不变，不需要切换当前使用的页表。 kill与kill -9的区别 默认情况下kill命令的参数为-15， 代表的信号为SIGTERM，这是告诉进程你需要被关闭，请自行停止运行并退出； 而kill -9代表的信号是SIGKILL，表示进程被终止，需要立即退出； 因此kill -9表示强制杀死该进程，这个信号不能被捕获也不能被忽略。 内存分配算法 最优匹配：遍历查找，性能较差。产生很多难以利用的小块 最差匹配：需要遍历、导致过量的碎片 首次匹配：速度优势、空闲块按内存地址排序 下次匹配：维护一个指针，指向上一个查找结束的位置，查找操作扩散到整个列表中去。 零拷贝原理","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://vivarisk.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"刷题-其他","slug":"刷题-其他","date":"2022-06-06T02:30:52.000Z","updated":"2022-08-18T17:09:15.068Z","comments":true,"path":"posts/48339ee4.html","link":"","permalink":"https://vivarisk.github.io/posts/48339ee4","excerpt":"记录一些刷题中需要注意的小问题","text":"记录一些刷题中需要注意的小问题 负数作被除数，-2 % 6 = -2，直接把负号加前面 （无符号右移）逻辑右移&gt;&gt;&gt; 机制转换，504，405 质数，204 Excel表问题，171，168 质因数，172","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://vivarisk.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"刷题-回溯","slug":"刷题：回溯","date":"2022-06-04T03:48:10.000Z","updated":"2022-06-06T01:20:41.332Z","comments":true,"path":"posts/b7ff5df1.html","link":"","permalink":"https://vivarisk.github.io/posts/b7ff5df1","excerpt":"回溯的题，这类题老是忘","text":"回溯的题，这类题老是忘 虽然不是回溯，力扣1091 最短、最优解这些用广度优先搜索，找到所有解的两个都行，但一般还是深度优先搜索更好写。 深度优先搜索 力扣695， 200， 547， 130 回溯 力扣17， 93， 79， 257，46，47，77，39，216，78，90，131 93题：复原IP地址 class Solution { public List&lt;String&gt; restoreIpAddresses(String s) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); if(s.length() &lt; 4){ return list; } backtrack(s, new StringBuilder(), 0, list); return list; } private void backtrack(String s, StringBuilder prefix, int num, List&lt;String&gt; list){ if(num == 4 || s.length() == 0){ if(num == 4 &amp;&amp; s.length() == 0){ list.add(prefix.toString()); } return; } int n = s.length(); for(int i=0; i&lt;n &amp;&amp; i&lt;=2; ++i){ if(i != 0 &amp;&amp; s.charAt(0) == '0'){ return; } String curr = s.substring(0, i+1); if(Integer.valueOf(curr) &lt;= 255){ if(num != 0){ curr = \".\" + curr; } prefix.append(curr); backtrack(s.substring(i+1), prefix, num+1, list); prefix.delete(prefix.length()-curr.length(), prefix.length()); } } } } 力扣257 class Solution { public List&lt;String&gt; binaryTreePaths(TreeNode root) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); dfs(root, new StringBuilder(), list); return list; } private void dfs(TreeNode root, StringBuilder path, List&lt;String&gt; list){ path.append(root.val + \"\"); if(root.left == null &amp;&amp; root.right == null){ list.add(path.toString()); return; } if(root.left != null){ dfs(root.left, new StringBuilder(path).append(\"-&gt;\"), list); } if(root.right != null){ dfs(root.right, new StringBuilder(path).append(\"-&gt;\"), list); } } } 力扣47 for(int i=0; i&lt;n; ++i){ if(!isVisited[i]){ isVisited[i] = true; path.add(nums[i]); backtrack(nums, list, path, isVisited); path.remove(path.size()-1); isVisited[i] = false; //111123, 回溯后，跳到最后一个1，for循环那还有一个++i，从2开始 while(i &lt; n-1 &amp;&amp; nums[i] == nums[i+1]){ ++i; } } } 有顺序的，排列：for循环从0开始 没顺序的，组合：for循环从start开始，传参 ​ 力扣131 class Solution { public List&lt;List&lt;String&gt;&gt; partition(String s) { List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); List&lt;String&gt; path = new ArrayList&lt;&gt;(); backtrack(s, list, path); return list; } private void backtrack(String s, List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; path){ if(s.length() == 0){ list.add(new ArrayList&lt;&gt;(path)); return; } int n = s.length(); for(int i=0; i&lt;n; ++i){ if(check(s, i)){ path.add(s.substring(0, i+1)); backtrack(s.substring(i+1), list, path); path.remove(path.size()-1); } } } private boolean check(String s, int k){ int i = 0, j = k; while(i &lt; j){ if(s.charAt(i++) != s.charAt(j--)){ return false; } } return true; } }","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://vivarisk.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"回溯","slug":"回溯","permalink":"https://vivarisk.github.io/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"刷题-分治","slug":"刷题-分治","date":"2022-06-02T15:28:03.000Z","updated":"2022-06-06T01:22:45.982Z","comments":true,"path":"posts/756833e6.html","link":"","permalink":"https://vivarisk.github.io/posts/756833e6","excerpt":"关于分治的题，就记住吧","text":"关于分治的题，就记住吧 力扣241 class Solution { //空间换时间，防止重复计算 private Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; diffWaysToCompute(String expression) { if(map.containsKey(expression)){ return map.get(expression); } List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int len = expression.length(); if(len == 0){ list.add(0); return list; } for(int i=0; i&lt;len; ++i){ char c = expression.charAt(i); if(isOps(c)){ List&lt;Integer&gt; left = diffWaysToCompute(expression.substring(0, i)); List&lt;Integer&gt; right = diffWaysToCompute(expression.substring(i+1)); for(int l : left){ for(int r : right){ list.add(caculate(c, l, r)); } } } } if(list.size() == 0){ list.add(Integer.valueOf(expression)); } map.put(expression, list); return list; } private boolean isOps(char c){ return c == '+' || c == '-' || c == '*'; } private int caculate(char c, int l, int r){ if(c == '+'){ return l + r; }else if(c == '-'){ return l - r; }else{ return l * r; } } } 力扣95 class Solution { public List&lt;TreeNode&gt; generateTrees(int n) { List&lt;TreeNode&gt;[][] dp = new ArrayList[n+1][n+1]; return generate(1, n, dp); } private List&lt;TreeNode&gt; generate(int start, int end, List&lt;TreeNode&gt;[][] dp){ List&lt;TreeNode&gt; list = new ArrayList&lt;&gt;(); //把特殊情况放前面，防止后面数组越界 if(start &gt; end){ list.add(null); return list; } if(dp[start][end] != null){ return dp[start][end]; } for(int i=start; i&lt;=end; ++i){ List&lt;TreeNode&gt; left = generate(start, i-1, dp); List&lt;TreeNode&gt; right = generate(i+1, end, dp); for(TreeNode l : left){ for(TreeNode r : right){ TreeNode root = new TreeNode(i); root.left = l; root.right = r; list.add(root); } } } dp[start][end] = list; return list; } }","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://vivarisk.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"分治","slug":"分治","permalink":"https://vivarisk.github.io/tags/%E5%88%86%E6%B2%BB/"}]},{"title":"二分查找","slug":"二分查找","date":"2022-06-02T12:49:51.000Z","updated":"2023-10-14T19:56:18.949Z","comments":true,"path":"posts/e8eb0481.html","link":"","permalink":"https://vivarisk.github.io/posts/e8eb0481","excerpt":"二分查找总结，模板和相关题","text":"二分查找总结，模板和相关题 参考邓俊辉老师的《数据结构》56页 返回第一个大于target值的索引 //始终满足[0, lo) &lt;= target, [hi, n) &gt; target public int searchInsert(int[] nums, int target) { int n = nums.length; int lo = 0, hi = n; while(lo &lt; hi){ int mi = (lo + hi) / 2; if(nums[mi] &lt;= target){ lo = mi + 1; }else{ hi = mi; } } //最后lo == hi, 返回第一个大于target的索引，返回lo--为插入位置 return lo; } 返回第一大于等于target值的索引 //始终满足[0, lo) &lt; target, [hi, n) &gt;= target public int searchInsert(int[] nums, int target) { int n = nums.length; int lo = 0, hi = n; while(lo &lt; hi){ int mi = (lo + hi) / 2; if(nums[mi] &lt; target){ lo = mi + 1; }else{ hi = mi; } } //最后lo == hi, 返回第一大于等于target的索引 return lo; } 这两种情况应该够用了。右边界取n还是n-1看具体情况，返回第一个大于或大于等于的，下标可能在n（即所有数都比target小），[lo,hi]是所求的下标范围，能取到n那hi就定到n。 有时候mi需要向上取整，这就不记了 相关题： 540，记住 153，比较mi和hi","categories":[{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://vivarisk.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二分","slug":"二分","permalink":"https://vivarisk.github.io/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"梦的现实延续","slug":"梦的现实延续","date":"2022-04-11T15:49:02.000Z","updated":"2023-10-14T22:27:00.233Z","comments":true,"path":"posts/459bb8ba.html","link":"","permalink":"https://vivarisk.github.io/posts/459bb8ba","excerpt":"一个奇怪的梦，醒后作。","text":"一个奇怪的梦，醒后作。 在我的价值观里，积极向上、努力奋斗是正确的。 没有朝着正确的方向努力会让我难过不安(这里需要一个更准确的词)。 努力奋斗了也并不会改变很多，1中观点会持续受阻，我渐渐躺平。 最后，这三个观点在可预见的时间里都不会改变，这些矛盾的想法、矛盾的内心想法与实际行动可能会让我在负面情绪中变得更消极但我也坚持了其他的我认为正确的，保持坦诚、保持善良等等。写下这些其实和我的日常生活出入很大，我平时只会想到3，只是偶尔比如现在才会想到1和2，所以绝大多时候我都很开心，就算现在也是，我接受这样一个矛盾的自己写下这些单纯地是怕我忘了1和2，因为我真的很少想着这些，前几天和朋友的聊天又无意中让我想到了这点。这是一种逃避吗，或许不是，但我的大脑自动忽略了它们，而在意识到后又感到一丝丝不安，当然这种感觉在变淡。遗忘可能导致我在未来情绪低落时找不到原因，当然这只能是原因之一或者压根不是现实中，一些形而下的，如中午吃什么、投哪家实习、多线程原理等等都占据着我的时间;而一些形而上的，看书看电影听歌等带来的艺术体验，发呆时大脑里的瞬时想法，又让我不觉时间流逝我的内心住着一个“白”，它没有任何价值判断，或许是完全的空白，这些年它逐渐长大，占据着我更多的时间空间两点睡的，六点多就醒了，现在却很清醒。梦里我在永夜中躲避一场大屠杀，奶奶出现了，她的音容笑貌真实可感，我要好好保护她。再一次见面让我感到幸福，在清醒时分写下这些。","categories":[{"name":"片段","slug":"片段","permalink":"https://vivarisk.github.io/categories/%E7%89%87%E6%AE%B5/"}],"tags":[]},{"title":"Hello World!","slug":"Hello-World-0","date":"1997-02-22T12:00:00.000Z","updated":"2022-06-01T16:10:24.496Z","comments":true,"path":"posts/1c291ca3.html","link":"","permalink":"https://vivarisk.github.io/posts/1c291ca3","excerpt":"","text":"世界，你好！","categories":[{"name":"生活","slug":"生活","permalink":"https://vivarisk.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[]}],"categories":[{"name":"生活","slug":"生活","permalink":"https://vivarisk.github.io/categories/%E7%94%9F%E6%B4%BB/"},{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"折腾","slug":"折腾","permalink":"https://vivarisk.github.io/categories/%E6%8A%98%E8%85%BE/"},{"name":"刷题","slug":"刷题","permalink":"https://vivarisk.github.io/categories/%E5%88%B7%E9%A2%98/"},{"name":"片段","slug":"片段","permalink":"https://vivarisk.github.io/categories/%E7%89%87%E6%AE%B5/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://vivarisk.github.io/tags/GitHub/"},{"name":"ssh","slug":"ssh","permalink":"https://vivarisk.github.io/tags/ssh/"},{"name":"Gridea","slug":"Gridea","permalink":"https://vivarisk.github.io/tags/Gridea/"},{"name":"朝花夕拾","slug":"朝花夕拾","permalink":"https://vivarisk.github.io/tags/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"},{"name":"Vim","slug":"Vim","permalink":"https://vivarisk.github.io/tags/Vim/"},{"name":"秋招","slug":"秋招","permalink":"https://vivarisk.github.io/tags/%E7%A7%8B%E6%8B%9B/"},{"name":"新冠","slug":"新冠","permalink":"https://vivarisk.github.io/tags/%E6%96%B0%E5%86%A0/"},{"name":"Shell","slug":"Shell","permalink":"https://vivarisk.github.io/tags/Shell/"},{"name":"学习","slug":"学习","permalink":"https://vivarisk.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Java并发","slug":"Java并发","permalink":"https://vivarisk.github.io/tags/Java%E5%B9%B6%E5%8F%91/"},{"name":"MySQL","slug":"MySQL","permalink":"https://vivarisk.github.io/tags/MySQL/"},{"name":"刷题","slug":"刷题","permalink":"https://vivarisk.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://vivarisk.github.io/tags/%E5%89%91%E6%8C%87offer/"},{"name":"jvm","slug":"jvm","permalink":"https://vivarisk.github.io/tags/jvm/"},{"name":"二叉树","slug":"二叉树","permalink":"https://vivarisk.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"链表","slug":"链表","permalink":"https://vivarisk.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"操作系统","slug":"操作系统","permalink":"https://vivarisk.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"回溯","slug":"回溯","permalink":"https://vivarisk.github.io/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"分治","slug":"分治","permalink":"https://vivarisk.github.io/tags/%E5%88%86%E6%B2%BB/"},{"name":"二分","slug":"二分","permalink":"https://vivarisk.github.io/tags/%E4%BA%8C%E5%88%86/"}]}