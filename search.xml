<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Gridea试用</title>
    <url>/posts/e3a44761.html</url>
    <content><![CDATA[<p>试用一下Gridea，之前了解过一点，用GUI界面简化了博客的搭建过程。主要参考官方文档<a href="https://gridea.dev/gridea-start/">快速上手</a></p>
<blockquote>
<p>一点小问题：在一台电脑上用两个github账号有点问题，在虚拟机中试的。后面的截图是在ubuntu中，不影响</p>
</blockquote>
<h3 id="创建账号"><a href="#创建账号" class="headerlink" title="创建账号"></a>创建账号</h3><p>创建一个github账号</p>
<h3 id="申请token"><a href="#申请token" class="headerlink" title="申请token"></a>申请token</h3><p>申请一个token</p>
<ol>
<li><p>在github主页点击右上角头像；左侧导航栏划到最后，点击Developer     </p>
<p>Settings；再点击Personal access tokens下的Tokens (classic)</p>
</li>
<li><p>Note随便填，过期时间选永不过期就好，权限只勾repo就行</p>
</li>
<li><p>下方点击确认并复制token (token保存一下，只显示这一次)，如图：</p>
</li>
</ol>
<p><img src="https://huangsl-1304681817.cos.ap-beijing.myqcloud.com/img/image-20230130115340672.png" alt="image-20230130115340672"></p>
<p><img src="https://huangsl-1304681817.cos.ap-beijing.myqcloud.com/img/image-20230130120011856.png" alt="image-20230130120011856"></p>
<h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>点击头像下拉选项框里的your repositories，再点击绿色New按钮。仓库名: 用户名.github.io, 其他都不用填</p>
<p><img src="https://huangsl-1304681817.cos.ap-beijing.myqcloud.com/img/image-20230130120427094.png" alt="image-20230130120427094"></p>
<h3 id="配置gridea"><a href="#配置gridea" class="headerlink" title="配置gridea"></a>配置gridea</h3><p>安装gridea客户端，点击远程。分支填main，令牌填刚才的token</p>
<p><img src="https://huangsl-1304681817.cos.ap-beijing.myqcloud.com/img/image-20230130150419586.png" alt="image-20230130150419586"></p>
<p>点检测远程连接试一试，在win上只有第一次成功了，在ubuntu上就没成功过。连不上也没事</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在文章那里新建，写作界面比较简陋，远不如typora</p>
<p>右侧提供了一些实用功能，设置摘要、置顶文章、emoji表情、预览等</p>
<p>不建议插入太多图片，图片直接在仓库里，一是github访问速度问题，二是太占仓库空间</p>
<p>写完保存后，点左下角的同步。同步很玄学，目测走的https</p>
<p><img src="https://huangsl-1304681817.cos.ap-beijing.myqcloud.com/img/image-20230130154555838.png" alt="image-20230130154555838"></p>
<p>具体见<a href="https://pica2pica.github.io/">https://pica2pica.github.io/</a></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>使用上较hexo简单一些，不需要命令行操作。本地和远程仓库的同步很玄学，可能是我网络的问题。总体使用体验不如hexo，后续有时间可以再摸索一下</p>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>Gridea</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World!</title>
    <url>/posts/1c291ca3.html</url>
    <content><![CDATA[<p>世界，你好！</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>MIT-Missing-Semester笔记(二):Vim</title>
    <url>/posts/1d744e80.html</url>
    <content><![CDATA[<p>关于Vim，不知道该怎么写，用得实在不多，零零散散写写。这篇以后用来记一记常用的Vim命令</p>
<p>参考<a href="https://learn.microsoft.com/zh-cn/windows/wsl/install">WSL安装</a>在win11上安装了WSL，简单用着体验很好</p>
<p>Vim的设计哲学：你大部分时间都在阅读浏览代码，不是在写代码</p>
<p>Vim分为下面几种模式：</p>
<ul>
<li>normal：HJKL分别对应左、下、上、右，浏览阅读</li>
<li>insert：按i进入，编辑代码</li>
<li>command：按：进入，执行一些命令（保存、退出、查找等）</li>
<li>replace：替换文本</li>
<li>visual：用于选定范围文本复制</li>
</ul>
<p>其他模式按esc回到normal模式</p>
<h3 id="tab、buffer、window"><a href="#tab、buffer、window" class="headerlink" title="tab、buffer、window"></a>tab、buffer、window</h3><p>Vim里的比较重要的几个概念，tab像是浏览器打开的多个标签、buffer对应打开的一个文件、window是一个tab里打开的多个窗口。一个buffer可以对应多个window，可以同时看一个文件的不同部分</p>
<p>:sp :vsp [file] 垂直/水平打开新的窗口，ctrl+w+方向切换窗口</p>
<p>:tabnew 打开新标签</p>
<p>:tabn :tabN 切换下/上一个标签，Vim里用大写表示上一个的时候很多</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p>不小心ctrl+z将Vim置于后台，使用<code>jobs</code>命令显示所有后台命令，<code>fg 1</code>恢复序号为1的Vim进程</p>
</li>
<li><p>查找、替换</p>
</li>
</ul>
<p>:/ 查找，用到再查</p>
<p>:s 替换，用到再查</p>
<ul>
<li>Vim的接口本身就是一种编程语言，可以组合多个键，例如<code>3dw</code>删除后面的三个单词</li>
</ul>
]]></content>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT-Missing-Semester笔记(四): 命令行环境</title>
    <url>/posts/1f8a8f12.html</url>
    <content><![CDATA[<h3 id="任务控制"><a href="#任务控制" class="headerlink" title="任务控制"></a>任务控制</h3><h4 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h4><p>输入 <code>Ctrl-C</code> 时，shell 会发送一个<code>SIGINT</code> 信号到进程。<code>SIGQUIT</code> 信号，通过输入<code>Ctrl-\</code>可以发送该信号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> signal, time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handler</span>(<span class="params">signum, time</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nI got a SIGINT, but I am not stopping&quot;</span>)</span><br><span class="line"></span><br><span class="line">signal.signal(signal.SIGINT, handler)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    time.sleep(<span class="number">.1</span>)</span><br><span class="line">    <span class="comment"># \n 换新行 \r 刷新当前行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\r&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><code>SIGTERM</code> 则是一个更加通用的、也更加优雅地退出信号。为了发出这个信号我们需要使用 <a href="https://www.man7.org/linux/man-pages/man1/kill.1.html"><code>kill</code></a> 命令, 它的语法是： <code>kill -TERM &lt;PID&gt;</code>。</p>
<h4 id="暂停和后台执行进程"><a href="#暂停和后台执行进程" class="headerlink" title="暂停和后台执行进程"></a>暂停和后台执行进程</h4><p><code>Ctrl-Z</code> 会让 shell 发送 <code>SIGTSTP</code> 信号</p>
<p><code>jobs</code>列出当前终端会话的未完成任务，通过编号引用任务（直接123，或加%）</p>
<p><code>kill</code>命令只能通过%来操作任务，<code>fg</code>、<code>bg</code>可以直接123</p>
<p><code>jobs</code>中<code>+</code>为最后第一个放入后台的任务，<code>-</code>为倒数第二个放入后台的任务</p>
<p>恢复暂停的工作<code>fg</code>、<code>bg</code>（前台、后台）</p>
<p><code>pgrep</code>检索pid</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ python3 sigint.py</span><br><span class="line">24^Z</span><br><span class="line">[1]+  Stopped                 python3 sigint.py</span><br><span class="line">$ <span class="built_in">fg</span> 1</span><br><span class="line">python3 sigint.py</span><br><span class="line">43^Z</span><br><span class="line">[1]+  Stopped                 python3 sigint.py</span><br><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">[1]+  Stopped                 python3 sigint.py</span><br><span class="line">$ pgrep -l python</span><br><span class="line">2824 python3</span><br><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">[1]-  Stopped                 python3 sigint.py</span><br><span class="line">[2]+  Stopped                 <span class="built_in">sleep</span> 1000</span><br><span class="line">$ <span class="built_in">kill</span> -SIGHUP %1</span><br><span class="line">[1]-  Stopped                 python3 sigint.py</span><br><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line"><span class="comment"># 贴心地再显示一次</span></span><br><span class="line">[1]-  Hangup                  python3 sigint.py</span><br><span class="line">[2]+  Stopped                 <span class="built_in">sleep</span> 1000</span><br><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">[2]+  Stopped                 <span class="built_in">sleep</span> 1000</span><br></pre></td></tr></table></figure>
<blockquote>
<p>命令中的 <code>&amp;</code> 后缀可以让命令在直接在后台运行，这使得可以直接在 shell 中继续做其他操作，不过它此时还是会使用 shell 的标准输出，这一点有时会比较恼人（这种情况可以使用 shell 重定向处理）。</p>
</blockquote>
<p><strong>-u     Force the stdout and stderr streams to be unbuffered</strong></p>
<p><code>python3 -u</code>直接重定向，不经过缓冲，否则重定向到其他文件可能不显示？</p>
<p><strong>关闭终端（会发送另外一个信号<code>SIGHUP</code>）</strong></p>
<p> <code>nohup</code> (一个用来忽略 <code>SIGHUP</code> 的封装) ，<code>kill -SIGHUP</code>对它无效</p>
<p><code>SIGKILL</code> 是一个特殊的信号，不能被进程捕获并且它会马上结束该进程。传说中的9号，会留下孤儿进程</p>
<p><code>kill</code>默认是15，<code>SIGTERM</code></p>
<h3 id="终端多路复用：tmux"><a href="#终端多路复用：tmux" class="headerlink" title="终端多路复用：tmux"></a>终端多路复用：tmux</h3><p>tmux可以方便地在终端上操作多个窗口，通过三个层级管理：会话（session）、窗口（window）、面板（pane）</p>
<p>这有篇很好的教程<a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">A Quick and Easy Guide to tmux</a></p>
<p>tmux的快捷键都是先按<code>Ctrl+b</code>，再按某功能键</p>
<p><img src="C:\Users\10710\AppData\Roaming\Typora\typora-user-images\image-20230710151428980.png" alt="image-20230710151428980"></p>
<ul>
<li>session<ul>
<li><code>tmux</code>开始一个新的会话</li>
<li><code>tmux new -s NAME</code>以指定名称开始一个新会话</li>
<li><code>tmux ls</code>列出当前会话</li>
<li>输入<code>Ctrl+b d</code>与当前会话分离</li>
<li><code>tmux attach -t NAME</code>连接指定会话，a就行，<code>[-t target-session]</code></li>
<li><code>tmux kill-session -t NAME</code>删除指定会话，<code>Ctrl+d</code>退出则直接删除</li>
</ul>
</li>
<li>window：类似浏览器的标签，下边状态栏加*的是当前窗口<ul>
<li><code>Ctrl+b c</code>创建新窗口</li>
<li><code>Ctrl+b number</code>跳转指定窗口</li>
<li><code>Ctrl+b ,</code>重命名当前窗口</li>
</ul>
</li>
<li>pane 可以将当前窗口分屏<ul>
<li><code>Ctrl+b %</code>竖直分屏</li>
<li><code>Ctrl+b &quot;</code>水平分屏</li>
<li><code>Ctrl+b 上下左右</code>在不同pane中跳转</li>
<li><code>Ctrl+b z</code>最大/小化当前pane</li>
<li><code>Ctrl+d</code>关闭当前pane</li>
</ul>
</li>
</ul>
<p>确实很方便</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
  </entry>
  <entry>
    <title>MIT-Missing-Semester笔记(一):Shell</title>
    <url>/posts/f350bbc1.html</url>
    <content><![CDATA[<p>MIT的课程：<a href="https://missing.csail.mit.edu/2020/">Missing Semester</a></p>
<p>介绍了Shell、vim、git等一些常用工具</p>
<p>检查Shell语法错误的在线网站<a href="https://www.shellcheck.net/">ShellCheck</a></p>
<h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>一开始介绍了一些常用的命令，大部分之前使用过。</p>
<p>重定向符号<code>&lt;</code>、<code>&gt;</code>，追加用<code>&gt;&gt;</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello</span><br><span class="line"><span class="built_in">cd</span> - <span class="comment">#回到上一个目录</span></span><br><span class="line"><span class="built_in">cat</span> 2.txt &gt;&gt; 1.txt</span><br><span class="line"><span class="built_in">ls</span> -l | <span class="built_in">tail</span> -n3 <span class="comment">#输出最后三行</span></span><br><span class="line">man <span class="built_in">ls</span> <span class="comment">#多用man</span></span><br><span class="line"><span class="built_in">ls</span> -<span class="built_in">ls</span> <span class="comment">#-l显示详细信息，-s显示文件占用块数block，后面可跟上目录</span></span><br><span class="line">4 -rwxrw-r-- 1 hsl hsl  132 12月  3 20:26 <span class="built_in">test</span></span><br><span class="line"><span class="comment">#文件占用块数、-文件d目录l链接</span></span><br><span class="line"><span class="comment">#权限：rwx读写执行权限，分别是拥有者、用户组、其他人</span></span><br><span class="line"><span class="comment">#文件数量、拥有者、用户组、时间、文件名</span></span><br><span class="line"><span class="built_in">chmod</span> u+x <span class="built_in">test</span></span><br><span class="line">curl --<span class="built_in">head</span> --silent google.com | grep --ignore-case content-length | <span class="built_in">cut</span> --delimiter=<span class="string">&#x27; &#x27;</span> -f2</span><br></pre></td></tr></table></figure>
<p>\转义字符，<code>mkdir my\ photo</code>将空格转义，否则会建立两个目录</p>
<p>touch命令本意是修改时间戳，-a修改访问时间，-m改变修改时间，文件不存在时会默认新建</p>
<p>.sh文件开头<code>#!/bin/sh</code>是shebang，指示解释器运行环境</p>
<p>/sys目录下有很多系统设置，一切皆文件！</p>
<p>tee命令读取标准输入，写到标准输出和文件</p>
<p>还讲了find、grep、curl、cut命令，后面再看一下</p>
<h3 id="变量、函数"><a href="#变量、函数" class="headerlink" title="变量、函数"></a>变量、函数</h3><p>变量定义: <code>foo=bar</code>, 等号左右不能有空格，否则相当于调用foo命令，=和bar作参数。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">foo=bar <span class="comment">#单引号、双引号不同</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$foo</span>&quot;</span></span><br><span class="line"><span class="comment"># prints bar</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$foo&#x27;</span></span><br><span class="line"><span class="comment"># prints $foo</span></span><br></pre></td></tr></table></figure>
<p>写一个mcd命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> mcd.sh</span><br><span class="line"><span class="function"><span class="title">mcd</span></span> () &#123;</span><br><span class="line">	<span class="built_in">mkdir</span> -p <span class="variable">$1</span></span><br><span class="line">	<span class="built_in">cd</span> <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">source</span> mcd.sh</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$0</code> - Name of the script</li>
<li><code>$1</code> to <code>$9</code> - Arguments to the script. <code>$1</code> is the first argument and so on.</li>
<li><code>$@</code> - All the arguments</li>
<li><code>$#</code> - Number of arguments</li>
<li><code>$?</code> - Return code of the previous command</li>
<li>$$$$ - Process identification number (PID) for the current script</li>
<li><code>!!</code> - Entire last command, including arguments. A common pattern is to execute a command only for it to fail due to missing permissions; you can quickly re-execute the command with sudo by doing <code>sudo !!</code></li>
<li><code>$_</code> - Last argument from the last command. If you are in an interactive shell, you can also quickly get this value by typing <code>Esc</code> followed by <code>.</code> or <code>Alt+.</code></li>
</ul>
<p>详细见：<a href="https://missing.csail.mit.edu/2020/shell-tools/">https://missing.csail.mit.edu/2020/shell-tools/</a></p>
<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p><strong>command substitution</strong></p>
<p><code>for file in $(ls)</code></p>
<p><strong>process substitution</strong></p>
<p><code>diff &lt;(ls foo) &lt;(ls bar)</code>, &lt;( CMD ) 将执行 CMD 并将输出放在一个临时文件中，并将 &lt;() 替换为该文件的名称。</p>
<h3 id="脚本举例"><a href="#脚本举例" class="headerlink" title="脚本举例"></a>脚本举例</h3><p>举例（<strong>比较时尽量使用双方括号</strong>, <a href="http://mywiki.wooledge.org/BashFAQ/031">why</a>）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Starting program at <span class="subst">$(date)</span>&quot;</span> <span class="comment"># Date will be substituted</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Running program <span class="variable">$0</span> with <span class="variable">$#</span> arguments with pid $$&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    grep foobar <span class="string">&quot;<span class="variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null</span><br><span class="line">    <span class="comment"># When pattern is not found, grep has exit status 1</span></span><br><span class="line">    <span class="comment"># We redirect STDOUT and STDERR to a null register since we do not care about them</span></span><br><span class="line">    <span class="keyword">if</span> [[ $? -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;File <span class="variable">$file</span> does not have any foobar, adding one&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;# foobar&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<ul>
<li>正则表达式</li>
</ul>
<p>? 匹配一个任意字符，* 匹配多个，{} 匹配花括号里所有</p>
<p>一个python脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="built_in">reversed</span>(sys.argv[<span class="number">1</span>:]):</span><br><span class="line">    <span class="built_in">print</span>(arg)</span><br></pre></td></tr></table></figure>
<p>shebang写成这样移植性更好</p>
<h3 id="函数和脚本"><a href="#函数和脚本" class="headerlink" title="函数和脚本"></a>函数和脚本</h3><ul>
<li>函数（平时一般叫命令？）必须和shell用同样的语言，脚本可以用任何语言，所以shebang很重要。</li>
<li>函数在读取其定义时加载一次。每次执行脚本时都会加载脚本。这使得函数的加载速度稍快一些，但是无论何时更改它们，都必须重新加载它们的定义。source命令吧</li>
<li>函数在当前的 shell 环境中执行，而脚本在它们自己的进程中执行。因此，函数可以修改环境变量，例如更改当前目录，而脚本不能。后面再看下export命令</li>
</ul>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Find all directories named src</span></span><br><span class="line">find . -name src -<span class="built_in">type</span> d</span><br><span class="line"><span class="comment"># *匹配0个或多个目录，在文件那匹配0个或多个字符，？只能匹配一个</span></span><br><span class="line">find . -path <span class="string">&#x27;*/test/*.py&#x27;</span> -<span class="built_in">type</span> f</span><br><span class="line"><span class="comment"># Find all files modified in the last day</span></span><br><span class="line">find . -mtime -1</span><br><span class="line"><span class="comment"># Find all zip files with size in range 500k to 10M</span></span><br><span class="line">find . -size +500k -size -10M -name <span class="string">&#x27;*.tar.gz&#x27;</span></span><br><span class="line"><span class="comment"># Find all python files where I used the requests library</span></span><br><span class="line">rg -t py <span class="string">&#x27;import requests&#x27;</span></span><br><span class="line"><span class="comment"># Find all files (including hidden files) without a shebang line</span></span><br><span class="line">rg -u --files-without-match <span class="string">&quot;^#!&quot;</span></span><br><span class="line"><span class="comment"># Find all matches of foo and print the following 5 lines</span></span><br><span class="line">rg foo -A 5</span><br><span class="line"><span class="comment"># Print statistics of matches (# of matched lines and files )</span></span><br><span class="line">rg --stats PATTERN</span><br><span class="line"><span class="comment"># -R递归搜索目录，-n显示行号，-C显示邻近几行</span></span><br><span class="line">grep -R -n -C 5 foobar .</span><br></pre></td></tr></table></figure>
<p>其他类似grep的搜索工具 <a href="https://github.com/beyondgrep/ack3">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a>和<a href="https://github.com/BurntSushi/ripgrep">rg</a>, 模糊匹配的<a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a>. 还有两个终端文件管理工具，<a href="https://github.com/jarun/nnn"><code>nnn</code></a> 和 <a href="https://github.com/ranger/ranger"><code>ranger</code></a>，看着挺炫酷，后面试一试</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://tldr.sh/">tldr</a>工具</p>
</li>
<li><p>一些命令不能从管道中读取数据，xargs可以将标准输入转化为参数。<code>ls | xargs rm</code></p>
</li>
</ul>
<h3 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h3><ol>
<li><p><code>ls -lath --color=auto</code>, -a显示隐藏文件，-t按修改时间降序排列，-h大小显示为多少M，多少k的形式。</p>
</li>
<li><p>执行marco时记录下当前目录，执行polo时回到之前记录的目录。</p>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">marco</span></span>() &#123;</span><br><span class="line">	<span class="built_in">export</span> MARCO=$(<span class="built_in">pwd</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">polo</span></span>() &#123;</span><br><span class="line">	<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$MARCO</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>运行err.sh脚本, 记录其输出和错误日志, 输出其出错时的运行次数</li>
</ol>
<p>err.sh</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"> n=$(( RANDOM % <span class="number">100</span> ))</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> [[ n -eq 42 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Something went wrong at <span class="subst">$(date)</span>&quot;</span></span><br><span class="line">    <span class="comment"># &gt;2是将输出重定向到文件2, &amp;2才是标准错误</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The error was using magic numbers&quot;</span> 1&gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Everything went according to plan&quot;</span></span><br></pre></td></tr></table></figure>
<p>errTest.sh</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">rm</span> record.txt record2.txt</span><br><span class="line">t=1</span><br><span class="line">./err.sh &gt; ./record.txt 2&gt; ./record2.txt</span><br><span class="line"><span class="keyword">while</span> [[ $? -eq 0 ]]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">let</span> t++</span><br><span class="line">	./err.sh &gt;&gt; ./record.txt 2&gt;&gt; ./record2.txt</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">cat</span> record.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;------&quot;</span></span><br><span class="line"><span class="built_in">cat</span> record2.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;run counts: <span class="variable">$t</span>&quot;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>搜索当前文件下的html文件并打包压缩，搜索出来的内容以换行符区分 ( 排除文件名中包含空格的情况 ) .</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xargs -d 指定分隔符</span></span><br><span class="line">find -name <span class="string">&quot;*.html&quot;</span> | xargs -d <span class="string">&#x27;\n&#x27;</span> tar -czvf archieve.tar.gz</span><br></pre></td></tr></table></figure>
<ol>
<li>递归搜索当前文件夹中的文件，按文件最后修改时间逆序排列</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># stat -c或--format格式化输出 Y是UNIX时间戳，y是可读时间，n文件名</span></span><br><span class="line"><span class="comment"># sort -n按数值比较 -r逆序</span></span><br><span class="line"><span class="comment"># cut -d分隔符 -f, --fields显示什么字段，从1开始，2-取第二个及以后</span></span><br><span class="line"><span class="comment"># head列出前几行，默认10</span></span><br><span class="line">find . -<span class="built_in">type</span> f | xargs -d <span class="string">&#x27;\n&#x27;</span> <span class="built_in">stat</span> --format <span class="string">&quot;%Y %y %n&quot;</span> | <span class="built_in">sort</span> -nr | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 2- | <span class="built_in">head</span> -n 5</span><br><span class="line">2022-12-28 20:46:34.869589528 +0800 ./22/33/1 3.html</span><br><span class="line">2022-12-28 20:46:00.144839386 +0800 ./22/2 .html</span><br><span class="line">2022-12-28 20:45:30.952572281 +0800 ./1.html</span><br><span class="line">2022-12-27 23:13:16.676754571 +0800 ./record.txt</span><br><span class="line">2022-12-27 23:13:16.676754571 +0800 ./record2.txt</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT Missing Semester笔记（三）</title>
    <url>/posts/b726205c.html</url>
    <content><![CDATA[<h3 id="数据整理"><a href="#数据整理" class="headerlink" title="数据整理"></a>数据整理</h3><p><strong>一些重要网址</strong></p>
<p>在线正则表达式调试工具<a href="https://regex101.com/">regex debugger</a></p>
<p>正则表达式<a href="https://regexone.com/">教程</a></p>
<hr>

<p>第四节课：数据整理，日志处理是典型的场景，比如<code>journalctl | grep -i intel</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh myserver <span class="string">&#x27;journalctl | grep sshd | grep &quot;Disconnected from&quot;&#x27;</span> | less</span><br></pre></td></tr></table></figure>
<p>将处理过程更多地放在服务器上，减少网络传输，<code>less</code>创建一个分页器</p>
<p><code>sed</code> 是一个基于文本编辑器<code>ed</code>构建的”流编辑器” ，如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep <span class="string">&quot;Disconnected from&quot;</span></span><br><span class="line"> | sed <span class="string">&#x27;s/.*Disconnected from //&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>s/REGEX/SUBSTITUTION/</code>，其中regex为正则表达式，现查现用吧</p>
<ul>
<li><code>.</code> 除换行符之外的”任意单个字符”</li>
<li><code>*</code> 匹配前面字符零次或多次</li>
<li><code>+</code> 匹配前面字符一次或多次</li>
<li><code>[abc]</code> 匹配 <code>a</code>, <code>b</code> 和 <code>c</code> 中的任意一个</li>
<li><code>(RX1|RX2)</code> 任何能够匹配<code>RX1</code> 或 <code>RX2</code>的结果</li>
<li><code>^</code> 行首</li>
<li><code>$</code> 行尾</li>
</ul>
<p><code>*</code>和<code>+</code>默认是贪心的，<code>sed</code>不支持在它们后面增加<code>?</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Jan 17 03:13:00 thesquareplanet.com sshd[2631]: Disconnected from </span></span><br><span class="line"><span class="comment"># invalid user Disconnected from 46.97.239.16 port 55920 [preauth]</span></span><br><span class="line"><span class="comment"># /.*Disconnected from /会匹配出</span></span><br><span class="line"><span class="comment"># 46.97.239.16 port 55920 [preauth]</span></span><br><span class="line">perl -pe <span class="string">&#x27;s/.*?Disconnected from //&#x27;</span></span><br><span class="line"><span class="comment"># 可以只匹配到第一个</span></span><br></pre></td></tr></table></figure>
<p>使用捕获组（capture groups）填充SUBSTITUTION部分，每个圆括号对应<code>\1</code>、 <code>\2</code>、<code>\3</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">| sed -E <span class="string">&#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span></span><br></pre></td></tr></table></figure>
<p>比较完整的处理</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep <span class="string">&quot;Disconnected from&quot;</span></span><br><span class="line"> | sed -E <span class="string">&#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span></span><br><span class="line"> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c</span><br><span class="line"> | <span class="built_in">sort</span> -nk1,1 | <span class="built_in">tail</span> -n10</span><br><span class="line"> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | <span class="built_in">paste</span> -sd,</span><br></pre></td></tr></table></figure>
<p><code>uniq -c</code> 会把连续出现的行折叠为一行并使用出现次数作为前缀， <code>paste</code>命令来合并行(<code>-s</code>)，并指定一个分隔符进行分割 (<code>-d</code>)。</p>
<p>对于<code>awk</code>，<code>$0</code> 表示整行的内容，<code>$1</code> 到 <code>$n</code> 为一行中的 n 个区域，区域的分割基于 <code>awk</code> 的域分隔符（默认是空格，可以通过<code>-F</code>来修改）。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计所有以c开头，以e结尾，并且仅尝试过一次登录的用户</span></span><br><span class="line"> | awk <span class="string">&#x27;$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ &#123; print $2 &#125;&#x27;</span> | <span class="built_in">wc</span> -l</span><br><span class="line"> <span class="comment"># wc为word count</span></span><br></pre></td></tr></table></figure>
<h4 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h4><p>命令可以从标准输入和参数中读取所处理的内容，管道控制的是标准输入输出，一些命令如<code>kill</code>、<code>rm</code>只能读取参数，需要使用xargs将标准输出变为参数，参考了一篇<a href="https://zhuanlan.zhihu.com/p/556154777">知乎专栏</a></p>
<p>具体用法可参考这篇<a href="https://www.cnblogs.com/chenxiaomeng/p/16040498.html">https://www.cnblogs.com/chenxiaomeng/p/16040498.html</a></p>
<h4 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h4><p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/data-wrangling-solution/">参考答案</a></p>
<p><strong>wsl并不是通过systemd进程启动的</strong>，在wsl中开启systemd参考<a href="https://devblogs.microsoft.com/commandline/systemd-support-is-now-available-in-wsl/">这个</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL笔记</title>
    <url>/posts/fd5f561d.html</url>
    <content><![CDATA[<p>MySQL学习过程中的一些知识点<span id="more"></span></p>
<ol>
<li>全部使用长连接，内存占用问题</li>
</ol>
<blockquote>
<p>1.定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后， 断开连接，之后要查询再重连。</p>
<p>2.如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执 行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权 限验证，但是会将连接恢复到刚刚创建完时的状态。</p>
</blockquote>
<ol>
<li>为什么不建议使用查询缓存</li>
</ol>
<blockquote>
<p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清 空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新 压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很 长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p>
</blockquote>
<ol>
<li><p>Write-Ahead Logging: 先写日志，再写磁盘</p>
</li>
<li><p>redolog只是完成了prepare, 而binlog又失败，那么事务本身会回滚</p>
</li>
</ol>
<blockquote>
<p>1 prepare阶段 2 写binlog 3 commit </p>
<p>当在2之前崩溃时 重启恢复：后发现没有commit，回滚。备份恢复：没有binlog 。 一致 </p>
<p>当在3之前崩溃 重启恢复：虽没有commit，但满足prepare和binlog完整，所以重启后会自动commit。备份：有binlog. 一致</p>
</blockquote>
<ol>
<li>一天一备份、一周一备份</li>
</ol>
<blockquote>
<p>RTO（恢复目标时间）好处是“最长恢复时间”更短。 在一天一备的模式里，最坏情况下需要应用一天的 binlog。当然这个是有成本的，因为更频繁全量备份需要消耗更多存储空间，所以这个 RTO 是成 本换来的，就需要你根据业务重要性来评估了。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm总结</title>
    <url>/posts/d6085898.html</url>
    <content><![CDATA[<p>jvm学习中的一些知识点<span id="more"></span></p>
<h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p>每一个实例对象的对象头，都有一个指针指向类对象（Class对象，在堆中，其中有类的静态变量），Class对象作为访问方法区中的类型数据的外部接口。</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题-二叉树</title>
    <url>/posts/55daf129.html</url>
    <content><![CDATA[<p>二叉树的题，递归要熟悉<span id="more"></span></p>
<ul>
<li>543，617，112</li>
</ul>
<p>力扣437</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        Map&lt;Long, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0L</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> recur(root, targetSum, map, <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">recur</span><span class="params">(TreeNode root, <span class="type">int</span> target, Map&lt;Long, Integer&gt; map, Long curr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr += root.val;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.getOrDefault(curr - target, <span class="number">0</span>);</span><br><span class="line">        map.put(curr, map.getOrDefault(curr, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//map存储当前节点和祖先节点的前缀和，传给子节点</span></span><br><span class="line">        count += recur(root.left, target, map, curr);</span><br><span class="line">        count += recur(root.right, target, map, curr);</span><br><span class="line">        <span class="comment">//路径是向下的，回溯时要删除当前节点对应的前缀和</span></span><br><span class="line">        map.put(curr, map.get(curr) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>路径问题：求数量可以用前缀和，求所有结果还是dfs</strong></p>
<ul>
<li>109，用全局变量</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/posts/e8eb0481.html</url>
    <content><![CDATA[<p>二分查找总结，模板和相关题<br><span id="more"></span></p>
<p><em>参考邓俊辉老师的《数据结构》56页</em></p>
<ol>
<li><p>返回第一个大于target值的索引</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//始终满足[0, lo) &lt;= target, [hi, n) &gt; target</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = n;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mi</span> <span class="operator">=</span> (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mi] &lt;= target)&#123;</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hi = mi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//最后lo == hi, 返回第一个大于target的索引，返回lo--为插入位置</span></span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回第一大于等于target值的索引</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//始终满足[0, lo) &lt; target, [hi, n) &gt;= target</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = n;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mi</span> <span class="operator">=</span> (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mi] &lt; target)&#123;</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hi = mi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//最后lo == hi, 返回第一大于等于target的索引</span></span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这两种情况应该够用了。右边界取n还是n-1看具体情况，返回第一个大于或大于等于的，下标可能在n（即所有数都比target小），[lo,hi]是所求的下标范围，能取到n那hi就定到n。</p>
<p>有时候mi需要向上取整，这就不记了</p>
<p>相关题：</p>
<ul>
<li>540，记住</li>
<li>153，比较mi和hi</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题-其他</title>
    <url>/posts/48339ee4.html</url>
    <content><![CDATA[<p>记录一些刷题中需要注意的小问题<span id="more"></span></p>
<ul>
<li>负数作被除数，-2 % 6 = -2，直接把负号加前面</li>
<li>（无符号右移）逻辑右移&gt;&gt;&gt;</li>
<li>机制转换，504，405</li>
<li>质数，204</li>
<li>Excel表问题，171，168</li>
<li>质因数，172</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题-分治</title>
    <url>/posts/756833e6.html</url>
    <content><![CDATA[<p>关于分治的题，就记住吧<br><span id="more"></span></p>
<ol>
<li>力扣241</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//空间换时间，防止重复计算</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">diffWaysToCompute</span><span class="params">(String expression)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(expression))&#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(expression);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> expression.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            list.add(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; ++i)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> expression.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(isOps(c))&#123;</span><br><span class="line">                List&lt;Integer&gt; left = diffWaysToCompute(expression.substring(<span class="number">0</span>, i));</span><br><span class="line">                List&lt;Integer&gt; right = diffWaysToCompute(expression.substring(i+<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l : left)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> r : right)&#123;</span><br><span class="line">                        list.add(caculate(c, l, r));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            list.add(Integer.valueOf(expression));</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(expression, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isOps</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">c</span> <span class="operator">=</span>= <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">caculate</span><span class="params">(<span class="type">char</span> c, <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l + r;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l - r;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> l * r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>力扣95</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;TreeNode&gt;[][] dp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> generate(<span class="number">1</span>, n, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, List&lt;TreeNode&gt;[][] dp)</span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//把特殊情况放前面，防止后面数组越界</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            list.add(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[start][end] != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[start][end];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;=end; ++i)&#123;</span><br><span class="line">            List&lt;TreeNode&gt; left = generate(start, i-<span class="number">1</span>, dp);</span><br><span class="line">            List&lt;TreeNode&gt; right = generate(i+<span class="number">1</span>, end, dp);</span><br><span class="line">            <span class="keyword">for</span>(TreeNode l : left)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode r : right)&#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(i);</span><br><span class="line">                    root.left = l;</span><br><span class="line">                    root.right = r;</span><br><span class="line">                    list.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[start][end] = list;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题-链表</title>
    <url>/posts/6db30a46.html</url>
    <content><![CDATA[<p>链表的题<span id="more"></span></p>
<ul>
<li>涉及到头节点的题，最好设一个dummy节点</li>
<li>24，445，234</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题-回溯</title>
    <url>/posts/b7ff5df1.html</url>
    <content><![CDATA[<p>回溯的题，这类题老是忘<span id="more"></span></p>
<ol>
<li><p>虽然不是回溯，<a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/">力扣1091</a></p>
<p>最短、最优解这些用广度优先搜索，找到所有解的两个都行，但一般还是深度优先搜索更好写。</p>
</li>
<li><p>深度优先搜索</p>
<p>力扣695， 200， 547， 130</p>
</li>
<li><p>回溯</p>
<p>力扣17， 93， 79， 257，46，47，77，39，216，78，90，131</p>
<p><a href="https://leetcode.cn/problems/restore-ip-addresses/submissions/">93题：复原IP地址</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(s, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), <span class="number">0</span>, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(String s, StringBuilder prefix, <span class="type">int</span> num, List&lt;String&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">4</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">4</span> &amp;&amp; s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">                list.add(prefix.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n &amp;&amp; i&lt;=<span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">curr</span> <span class="operator">=</span> s.substring(<span class="number">0</span>, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(Integer.valueOf(curr) &lt;= <span class="number">255</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">                    curr = <span class="string">&quot;.&quot;</span> + curr;</span><br><span class="line">                &#125;</span><br><span class="line">                prefix.append(curr);</span><br><span class="line">                backtrack(s.substring(i+<span class="number">1</span>), prefix, num+<span class="number">1</span>, list);</span><br><span class="line">                prefix.delete(prefix.length()-curr.length(), prefix.length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/binary-tree-paths/">力扣257</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, StringBuilder path, List&lt;String&gt; list)</span>&#123;</span><br><span class="line">        path.append(root.val + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            list.add(path.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            dfs(root.left, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(path).append(<span class="string">&quot;-&gt;&quot;</span>), list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            dfs(root.right, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(path).append(<span class="string">&quot;-&gt;&quot;</span>), list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/permutations-ii/">力扣47</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">          <span class="keyword">if</span>(!isVisited[i])&#123;</span><br><span class="line">              isVisited[i] = <span class="literal">true</span>;</span><br><span class="line">              path.add(nums[i]);</span><br><span class="line">              backtrack(nums, list, path, isVisited);</span><br><span class="line">              path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">              isVisited[i] = <span class="literal">false</span>;</span><br><span class="line">              <span class="comment">//111123, 回溯后，跳到最后一个1，for循环那还有一个++i，从2开始</span></span><br><span class="line">              <span class="keyword">while</span>(i &lt; n-<span class="number">1</span> &amp;&amp; nums[i] == nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                  ++i;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>有顺序的，排列：for循环从0开始</li>
<li>没顺序的，组合：for循环从start开始，传参</li>
</ul>
<p>​    <a href="https://leetcode.cn/problems/palindrome-partitioning/">力扣131</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrack(s, list, path);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(String s, List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(check(s, i))&#123;</span><br><span class="line">                path.add(s.substring(<span class="number">0</span>, i+<span class="number">1</span>));</span><br><span class="line">                backtrack(s.substring(i+<span class="number">1</span>), list, path);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String s, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = k;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i++) != s.charAt(j--))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer专项突击版刷题总结</title>
    <url>/posts/b59e3d2c.html</url>
    <content><![CDATA[<p>题解总结<br><span id="more"></span></p>
<ol>
<li>整数除法</li>
</ol>
<p>最后是都要取绝对值计算，先把特殊情况考虑到了；模拟草稿纸上的除法运算，比如10000/23，在百位上写4，余数就<strong>不可能</strong>在百位上写值了，是一个依次向低位上写值的过程，二进制一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == Integer.MIN_VALUE)&#123;</span><br><span class="line">            <span class="type">return</span> <span class="variable">a</span> <span class="operator">=</span>= Integer.MIN_VALUE ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a == Integer.MIN_VALUE)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b == -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(b == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                a += Math.abs(b);</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对布尔值可以做位运算，结果还是布尔值</span></span><br><span class="line">        <span class="comment">//int flag = (a &gt;&gt;&gt; 31) ^ (b &gt;&gt;&gt; 31)</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (a &gt; <span class="number">0</span>) ^ (b &gt; <span class="number">0</span>);</span><br><span class="line">        a = Math.abs(a);</span><br><span class="line">        b = Math.abs(b);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>; i&gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((a &gt;&gt;&gt; i) &gt;= b)&#123;</span><br><span class="line">                ans += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                a -= (b &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer刷题</title>
    <url>/posts/4f6f4f56.html</url>
    <content><![CDATA[<p>剑指offer从头刷一遍<span id="more"></span></p>
<ol>
<li><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指03</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组中重复的数字，当一个数和其下标不对应时，就把它交换到正确的位置，</span></span><br><span class="line"><span class="comment">//如果正确的位置有一个同样的值（就找到重复的了），</span></span><br><span class="line"><span class="comment">//while中每次都会有一个值处在正确的位置，时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] != i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[nums[i]] == nums[i])&#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                swap(nums, i, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">剑指07</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根节点以前序遍历下标为准，子树范围是中序遍历的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] preorder;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; inorderMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> inorder.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            inorderMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">recur</span><span class="params">(<span class="type">int</span> preRootIdx, <span class="type">int</span> inLeftIdx, <span class="type">int</span> inRightIdx)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inLeftIdx &gt; inRightIdx)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preRootVal</span> <span class="operator">=</span> preorder[preRootIdx];</span><br><span class="line">        <span class="type">int</span> <span class="variable">inRootIdx</span> <span class="operator">=</span> inorderMap.get(preRootVal);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preRootVal);</span><br><span class="line">        root.left = recur(preRootIdx+<span class="number">1</span>, inLeftIdx, inRootIdx-<span class="number">1</span>);</span><br><span class="line">        root.right = recur(preRootIdx + inRootIdx - inLeftIdx + <span class="number">1</span>, inRootIdx + <span class="number">1</span>, inRightIdx);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>剑指09：用两个栈实现队列。stack2只push，弹出时当stack1非空时弹出stack1，否则将stack2中所有元素出栈并入栈stack1，stack1再出栈。</p>
</li>
<li><p><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">154</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//旋转数组最小值，有重复</span></span><br><span class="line"><span class="comment">//比较mi和hi，相同时hi左移</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mi</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mi] &lt; nums[hi])&#123;</span><br><span class="line">                hi = mi;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mi] &gt; nums[hi])&#123;</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hi = hi - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><a href="https://leetcode.cn/problems/word-search/">79</a> 回溯的题</li>
<li><a href="https://leetcode.cn/problems/integer-break/">343整数拆分</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果一个因子大于4，拆成2和n-2一定更大</span></span><br><span class="line"><span class="comment">//4，拆成2+2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> n / <span class="number">3</span>, remainder = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(remainder == <span class="number">0</span>) <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>, a);</span><br><span class="line">        <span class="keyword">if</span>(remainder == <span class="number">1</span>) <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>, a-<span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>, a) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><a href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">二进制中1的个数</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//n &amp; (n-1)会消掉最低位的1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">快速幂</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            b = -b;</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                ans *= x;</span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">大数打印</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记住就完事了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] ans;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] printNumbers(<span class="type">int</span> n) &#123;</span><br><span class="line">        ans = <span class="keyword">new</span> <span class="title class_">int</span>[(<span class="type">int</span>)Math.pow(<span class="number">10</span>, n) - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">            dfs(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == len)&#123;</span><br><span class="line">            ans[count++] = Integer.parseInt(curr.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> (x == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;<span class="number">10</span>; ++i)&#123;</span><br><span class="line">            curr.append(i);</span><br><span class="line">            dfs(x+<span class="number">1</span>, len);</span><br><span class="line">            curr.deleteCharAt(curr.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://leetcode.cn/problems/regular-expression-matching/">正则表达式</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length(), n = p.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//s,p都为空默认匹配</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//s为空, p为.*也能匹配</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;=n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">2</span>) || p.charAt(j-<span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                        <span class="comment">//匹配0次或多次</span></span><br><span class="line">                        dp[i][j] = dp[i][j-<span class="number">2</span>] || dp[i-<span class="number">1</span>][j];</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//只能匹配0次</span></span><br><span class="line">                        dp[i][j] = dp[i][j-<span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">1</span>) || p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                        dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>并发学习</title>
    <url>/posts/54cc7e1f.html</url>
    <content><![CDATA[<p>并发编程里的知识点<span id="more"></span></p>
<ol>
<li>volatile</li>
</ol>
<p>是jvm提供的轻量级的同步机制：保证可见性、<strong>不保证原子性</strong>、禁止指令重排序</p>
<p>可见性：一个线程修改了主内存的值，要通知其他线程</p>
<ol>
<li>synchronized</li>
</ol>
<p>普通同步方法，锁是当前实例对象；静态同步方法，锁是当前类的Class对象；同步方法块：锁是括号里的对象。</p>
<ul>
<li>同步代码：通过moniterenter、moniterexit 关联到到一个monitor对象，进入时设置Owner为当前线程，计数+1、退出-1。除了正常出口的 monitorexit，还在异常处理代码里插入了 monitorexit。</li>
<li>实例方法：隐式调用moniterenter、moniterexit（ACC_SYNCHRONIZED）</li>
<li>静态方法：隐式调用moniterenter、moniterexit</li>
</ul>
<p>每一个对象都关联一个monitor，执行monitorenter时，会尝试获得对象对应的monitor的所有权，即尝试获得对象的锁。</p>
<p>在 HotSpot 虚拟机中，对象在内存中的布局分为三块区域：对象头，实例数据和对齐填充。对象头中包含两部分：MarkWord 和 类型指针。如果是数组对象的话，对象头还有一部分是存储数组的长度。多线程下 synchronized 的加锁就是对同一个对象的对象头中的 MarkWord 中的变量进行CAS操作。</p>
<p><img src="https://tech.youzan.com/content/images/2021/06/image-20210627210825952.png" alt="mariword"></p>
<p>epoch: 偏向时间戳<strong>后面再查查资料</strong></p>
<p>如果当前锁<strong>已偏向其他线程</strong>||<strong>epoch值过期</strong>||<strong>class偏向模式关闭</strong>||<strong>获取偏向锁的过程中存在并发冲突</strong>，都会进入到<code>InterpreterRuntime::monitorenter</code>方法， 在该方法中会进行偏向锁撤销和升级。</p>
<p><img src="https://tech.youzan.com/content/images/2021/07/---.svg" alt=""></p>
<p><strong>只有匿名偏向的对象才能进入偏向锁模式</strong>。偏向锁是延时初始化的，默认是4000ms。初始化后会将所有加载的Klass的prototype header修改为匿名偏向样式。当创建一个对象时，会通过Klass的prototype_header来初始化该对象的对象头。简单的说，偏向锁初始化结束后，后续所有对象的对象头都为<strong>匿名偏向</strong>样式，在此之前创建的对象则为<strong>无锁状态</strong>。而对于无锁状态的锁对象，如果有竞争，会直接进入到轻量级锁。这也是为什么JVM启动前4秒对象会直接进入到轻量级锁的原因。</p>
<p>为什么需要延迟初始化？</p>
<p>JVM启动时必不可免会有大量sync的操作，而偏向锁并不是都有利。如果开启了偏向锁，会发生大量锁撤销和锁升级操作，大大降低JVM启动效率。</p>
<p>因此，我们可以明确地说，只有锁对象处于<strong>匿名偏向</strong>状态，线程才能拿到到我们通常意义上的偏向锁。而处于无锁状态的锁对象，只能进入到轻量级锁状态。</p>
<p>无锁状态只能升级为轻量级锁，<strong>匿名偏向状态</strong>才能进入到偏向锁</p>
<p>3.偏向锁<strong>并不都有利，</strong>其适用于<strong>单个线程重入</strong>的场景，原因为：偏向锁的撤销需要进入<code>safepoint</code>，开销较大。需要进入<code>safepoint</code>是由于，偏向锁的撤销需要对锁对象的<code>lock record</code>进行操作，而<code>lock record</code>要到每个线程的栈帧中遍历寻找。在非safepoint，栈帧是动态的，会引入更多的问题。目前看来，偏向锁存在的价值是为历史遗留的Collection类如Vector和HashTable等做优化，迟早药丸。Java 15中默认不开启。<br>4.执行Object类的<code>hashcode</code>方法，偏向锁撤销并且锁会膨胀为轻量级锁或者重量锁。执行Object类的<code>wait/notify/notifyall</code>方法，偏向锁撤销并膨胀成重量级锁。<br>5.轻量级锁适用于<strong>两个线程的交替执行</strong>场景：线程A进入轻量级锁，退出同步代码块并释放锁，会将锁对象恢复为无锁状态；线程B再进入锁，发现为无锁状态，会cas尝试获取该锁对象的轻量级锁。如果有竞争，则直接膨胀为重量级锁，没有自旋操作，详情看10。</p>
<p><a href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">Java锁与线程的那些事</a></p>
<p>这篇写得太好了，后面一定好好看看</p>
<ol>
<li>volatile</li>
</ol>
<p><strong>原理</strong>：首先我们要了解线程在java内存里面执行的原理，每个线程获取到CPU的时钟区间之后，会从ready状态-&gt;running状态，在x86处理器下，每个线程在执行的时候，不会直接读取主内存，而是会在每个CPU的高速缓存里面读取数据，每次CPU在执行线程的时候，会将需要的数据从主内存读取到高速缓存中，而在多核CPU的情况下，如果一个CPU进行了计算，然而其他CPU里面的缓存数据还是旧的，那么就会导致计算出错（脏数据）的情况，为了避免这种情况，保证多个CPU之间的高速缓存是一致的，OS里面会有一个<strong>缓存一致性协议</strong>，volatile就是通过OS的缓存一致性策略来保持共享变量在多个线程之间的可见性。</p>
<blockquote>
<p>缓存一致性：每个CPU会在总线上面有一个嗅探器，当一个CPU将高速缓存的内容写到主内存时候，每个CPU会去查看自己缓存里面的缓存行对应的内存地址的值是否被修改了，如果发现被修改了，会将缓存里面的数据设为无效，当处理器要对自身告诉缓存里面的这个数据进行修改，会强制重新从系统主内存读取数据进来之后再去修改（详细可参考intel的mesi协议：<a href="https://link.jianshu.com?t=http%3A%2F%2Fblog.csdn.net%2Fmuxiqingyang%2Farticle%2Fdetails%2F6615199">http://blog.csdn.net/muxiqingyang/article/details/6615199</a>）。</p>
</blockquote>
<p><strong>局限性</strong>：由于volatile只是保持了共享变量的可见性，当多线程并发的时候，多个线程分别分配到CPU中，比如执行x++操作，我们都知道实际上<strong>x++ &lt;=&gt; x=x+1</strong>，那么x++不是一个原子操作而是一个两步的操作，当对共享变量使用volatile之后，在CPU1里面一个线程进行了+1操作，并将数据写回到主内存时候，根据缓存一致性策略，会将各个其他CPU高速缓存里面的缓存行设为无效，然而当此时另一个线程已经完成了从CPU告诉缓存段读取数据到变量的操作，此时变量的值已经在jvm的栈里面，虽然CPU2里面的缓存段已经失效了，但是在并发情况下，还是可能会出现数据丢失的情况，不能保证并发情况下对共享变量的访问。</p>
<p><strong>使用场景</strong>：</p>
<blockquote>
<p>(1)对变量的写操作不依赖于当前值。</p>
<p>(2)该变量没有包含在具有其他变量的不变式中。</p>
<p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>
</blockquote>
<p>所以可以看出，实际上volatile作为只保证可见性的并发策略，只适用于独立的不依赖于当前值的变量，一般来说是只能适合于Boolean变量并且是独立的与其他互不相关的Boolean变量，当然自从jdk1.5之后，java引进了CAS机制来保证volatile的原子性。</p>
<p>volatile适合一个线程写，多个线程读</p>
<p>CAS比synchronized快</p>
<p>（1）CAS是一个硬件指令，通过硬件层次去保证原子性，比synchronized在jvm层次通过一个监听者作为锁来保证原子性更快</p>
<p>（2）OS里面的<strong>LOCK</strong>指令分为两种锁：</p>
<p>1.一种是<strong>总线锁</strong>，当LOCK指令锁住的是总线的时候，那么每一刻只有一个CPU能够访问到总线，那样就保证了原子性的操作，但是由于同一时刻只有一个CPU，就是单线程能访问到总线，但因为是硬件上层次的锁，所以性能还是优于synchronized；</p>
<p>2.另外一种是<strong>缓存锁</strong>，当cmpxchg指令要操作的内存能完全保存在一个缓存行里面的时候，CPU高速缓存里面也完全缓存了这个缓存行，当要对缓存行进行写操作之前，根据缓存一致性策略会将缓存行修改为MESI里面的E（Exclusive）状态，当缓存行处于这个状态的时候，其他CPU里面不能访问这个缓存行的数据，就是说此时这个缓存行是被锁定独占的，那么CAS就会就直接执行cmpxchg指令而不去发出LOCK指令到总线，因为是独占的占有这个缓存行，所以也是一个原子性的操作。而因为缓存行层次上的锁更具有并发性和锁的时间更短，所以性能上比synchronized要快的多。</p>
<p>所以当同步锁的性能还不是系统性能瓶颈的时候，可以先考虑使用同步锁synchronized和lock，但是当同步锁的性能已经是系统瓶颈，那就要开始考虑使用CAS+volatile的非阻塞乐观锁的方式来降低同步锁带来的阻塞性能的问题</p>
<p><a href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/</a></p>
<p><a href="https://www.jianshu.com/p/cd4744d799e4">https://www.jianshu.com/p/cd4744d799e4</a></p>
<p><a href="https://www.cnblogs.com/wuqinglong/p/9945618.html">https://www.cnblogs.com/wuqinglong/p/9945618.html</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title>我的二〇二二</title>
    <url>/posts/9b29cd32.html</url>
    <content><![CDATA[<p>回望这一年，仍有强烈的不真实感，整体十分混乱，也就匆匆动笔了</p>
<p>时间赋予了我们“一周年”，也终将把我们吞没。当UNIX时间戳自增到1672502400时2023年开始，时间的流逝没有任何偏好。但总该有所纪念，地球公转一周，四时晨昏交替，在魔幻的2022年岁末，写下自己的第一个年终总结</p>
<p>近几年简单地说：在挫败中寻找光亮</p>
<hr>

<p>一个月过去了，今天是23年立春。回想起这一年多来，只能说自作自受，失望厌恶。认真努力吧，没什么可说的了</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>朝花夕拾</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统总结</title>
    <url>/posts/25519ab6.html</url>
    <content><![CDATA[<p>操作系统知识点总结<span id="more"></span></p>
<ol>
<li><strong>进程、线程、协程的区别</strong></li>
</ol>
<ul>
<li><p>进程指运行中的程序。一般我们希望同时运行多个程序，操作系统通过虚拟化CPU来提供这个假象，让一个进程只运行一个时间片，然后切换其他进程。进程是分配资源的单位，进程的机器状态（machine state，进程在运行时可以读取或更新的内容）：它的内存（地址空间）、寄存器。</p>
</li>
<li><p>线程是为单个进程提供的抽象，经典观点：一个程序只有一个执行点（一个PC），多线程程序有多个执行点（多个程序计数器，分别用于取指和执行），每个线程有一个程序计数器、一组寄存器。线程是调度的基本单位，把一个进程的资源分配和执行调度分开。线程间共享地址空间，能够访问相同的数据。</p>
</li>
</ul>
<p>​    (线程上下文切换类似于进程上下文切换，进程切换将状态保存到进程控制块（PCB），线程对应线程控制块（TCB）。线程切换地址空间不变，不需要切换当前使用的页表。）</p>
<ul>
<li>java线程的实现基于内核线程（实际上是内核进程的一个接口：轻量级进程），各种线程操作、切换都要进行系统调用，代价较高，需要在用户态、内核态切换，同时也会消耗一定内核资源，容纳的线程数量有限。1：1</li>
</ul>
<p>​    协程：用户线程，1：N。用户线程的建立、同步、销毁和调度完全在用户态中完成。操作快、消耗低，但    实现上比较复杂，需要应用层实现的内容（调用栈、调度器）特别多。</p>
<p>​    HotSpot中，java线程直接映射到操作系统原生线程，抢占式调度，调度最终由操作系统说了算。</p>
<ol>
<li><strong>进程间通信方式</strong></li>
</ol>
<p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为<strong>进程间通信（IPC，InterProcess Communication）</strong></p>
<p><a href="https://www.jianshu.com/p/c1015f5ffa74">https://www.jianshu.com/p/c1015f5ffa74</a></p>
<p>1.匿名管道</p>
<p>2.有名管道</p>
<p>3.信号</p>
<p>4.消息队列（内核中）</p>
<p>5.共享内存：多个进程共享一段内存</p>
<p>6.信号量：用于进程同步</p>
<p>7.套接字</p>
<p>3.<strong>死锁的产生条件和解决方案</strong></p>
<p>多个进程可以竞争有限数量的资源。当一个进程申请资源时，如果这时没有可用资源，那么这个进程进入等待状态。有时，如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变状态。这种情况称为 死锁。</p>
<ul>
<li><strong>互斥</strong>：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</li>
<li><strong>占有并等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</li>
<li><strong>非抢占</strong>：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li>
<li><strong>循环等待</strong>：有一组等待进程 <code>&#123;P0, P1,..., Pn&#125;</code>， <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，……，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</li>
</ul>
<p>解决死锁的方法</p>
<ul>
<li><p><strong>预防</strong> 是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间上都不满足。</p>
<p>1.<strong>静态分配策略</strong>：破坏第二个条件。一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。降低了资源利用率</p>
<p>2.<strong>层次分配策略</strong>：破坏第二个条件。在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它才能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的</p>
</li>
<li><p><strong>死锁避免</strong></p>
<p>当一个进程申请使用资源的时候，<strong>银行家算法</strong> 通过先 <strong>试探</strong> 分配给该进程资源，然后通过 <strong>安全性算法</strong> 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 <strong>真的分配资源给该进程</strong>。需要花费较多的时间。</p>
</li>
<li><p>死锁检测</p>
<ol>
<li>如果进程-资源分配图中无环路，则此时系统没有发生死锁</li>
<li>如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁。</li>
<li>如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁。如果能在进程-资源分配图中找出一个 <strong>既不阻塞又非独立的进程</strong> ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 <strong>消除所有的边</strong> ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 <strong>拓扑排序</strong>)</li>
</ol>
</li>
<li><p>死锁解除</p>
<ol>
<li><strong>立即结束所有进程的执行，重新启动操作系统</strong> ：这种方法简单，但以前所在的工作全部作废，损失很大。</li>
<li><strong>撤销涉及死锁的所有进程，解除死锁后继续运行</strong> ：这种方法能彻底打破<strong>死锁的循环等待</strong>条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。</li>
<li><strong>逐个撤销涉及死锁的进程，回收其资源直至死锁解除。</strong></li>
<li><strong>抢占资源</strong> ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。</li>
</ol>
</li>
</ul>
<p>4.<strong>虚拟内存及其作用介绍</strong></p>
<p>操作系统提供了一个易用的物理内存抽象：地址空间。一个进程的地址空间包含运行程序的所有内存状态、代码、栈和堆。</p>
<p>为什么要有虚拟内存：方便和易用性、支持多个并发进程</p>
<p>3个目标：</p>
<p>1.透明：程序感觉不到内存被虚拟化的事实，好像拥有自己的内存。操作系统和硬件完成了所有的工作。</p>
<p>2.效率：时间上不会使程序执行得更慢，空间上不太需要额外的内存。依靠硬件支持。</p>
<p>3.保护：一个进程不会影响其他进程或操作系统的内存内容（它的地址空间之外的内容），对进程之间提供隔离。</p>
<p>5.<strong>线程间通信方式</strong></p>
<ol>
<li><strong>互斥量(Mutex)</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li>
<li><strong>信号量(Semphares)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li>
<li><strong>事件(Event)</strong> :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>
</ol>
<p>6.<strong>进程调度算法</strong></p>
<p>1.先进先出FIFO</p>
<p>2.最短任务优先：非抢占式</p>
<p>3.最短完成时间优先：抢占式</p>
<p>4.时间片轮转</p>
<p>5.多级反馈队列</p>
<p>规则 1：如果 A 的优先级 &gt; B 的优先级，运行 A（不运行 B）。</p>
<p> 规则 2：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B。 </p>
<p>规则 3：工作进入系统时，放在最高优先级（最上层队列）。 </p>
<p>规则 4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）。 </p>
<p>规则 5：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。</p>
<p>6.比例份额：确保每个工作获得一定比例的CPU时间。彩票份额、行程值</p>
<ol>
<li><strong>用户态内核态区别</strong></li>
</ol>
<p>用户空间:指的就是用户可以操作和访问的空间，这个空间通常存放我们用户自己写的数据等等；而内核空间则是系统内核来操作的一块空间，这块空间里面存放系统内核的函数、接口等。<br>不管对于Linux还是Windows， 他们都具有自己用户空间和内核空间。当一个程序运行时，如果它是在用户空间下执行，我们把此时运行得程序的这种状态成为用户态，而当这段程序执行在内核的空间执行时，这种状态称为内核态。</p>
<p>用户模式（user mode）。在用户模式下运行的代码会受到限制。例如，在用户模式下运行时，进程不能发出 I/O 请求。这 样做会导致处理器引发异常，操作系统可能会终止进程。与用户模式不同的内核模式（kernel mode），操作系统（或内核）就以这种模式运行。 在此模式下，运行的代码可以做它喜欢的事，包括特权操作，如发出 I/O 请求和执行所有类 型的受限指令。</p>
<p>作用1：安全执行受限制的指令</p>
<p>作用2：实现进程切换</p>
<ol>
<li><strong>进程的状态</strong></li>
</ol>
<p>1.创建</p>
<p>2.就绪</p>
<p>3.运行</p>
<p>4.阻塞</p>
<p>5.结束</p>
<ol>
<li><strong>如何实现进程间共享内存？</strong></li>
</ol>
<p>为了支持共享，需要一些额外的硬件支持，这就是保护位（protection bit）。基本为每个段增加了几个位，标识程序是否能够读写该段，或执行其中的代码。通过将代码段标记为只 读，同样的代码可以被多个进程共享，而不用担心破坏隔离。虽然每个进程都认为自己独占 这块内存，但操作系统秘密地共享了内存，进程不能修改这些内存，所以假象得以保持。</p>
<ul>
<li><p>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</p>
</li>
<li><p>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</p>
</li>
<li><p>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>原理</th>
<th>易失性</th>
</tr>
</thead>
<tbody>
<tr>
<td>mmap</td>
<td>利用文件(open)映射共享内存区域</td>
<td>会保存在磁盘上，不会丢失</td>
</tr>
<tr>
<td>Posix shared memory</td>
<td>利用/dev/shm文件系统(mmap)映射共享内存区域</td>
<td>随内核持续，内核自举后会丢失</td>
</tr>
<tr>
<td>SystemV shared memory</td>
<td>利用/dev/shm文件系统(shmat)映射共享内存区域</td>
<td>随内核持续，内核自举后会丢失</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><strong>线程状态</strong></li>
</ol>
<p>java线程状态：</p>
<p>1.新建：创建后未启动</p>
<p>2.运行：包括操作系统中的Running和Ready</p>
<p>3.无限期等待（wait）：线程主动等待</p>
<p>4.限期等待：带时间的wait、join等</p>
<p>5.阻塞：等待获得一个排他锁</p>
<p>6.结束（terminated）</p>
<ol>
<li><strong>内存泄露概念与产生原因与影响</strong></li>
</ol>
<p>为内存泄露（memory leak），如果忘记释放内存，就会发生。系统中实际存在两级内存管理。 第一级是由操作系统执行的内存管理，操作系统在进程运行时将内存交给进程，并在进程退出（或以其他方式结束）时将其回收。第二级管理在每个进程中，例如在调用 malloc()和 free()时，在堆内管理。 即使你没有调用 free()（并因此泄露了堆中的内存），操作系统也会在程序结束运行时，收回进程的所有 内存（包括用于代码、栈，以及相关堆的内存页）。无论地址空间中堆的状态如何，操作系统都会在进程终止时收回所有这些页面，从而确保即使没有释放内存，也不会丢失内存。 因此，对于短时间运行的程序，泄露内存通常不会导致任何操作问题（尽管它可能被认为是不好的形式）。如果你编写一个长期运行的服务器（例如 Web 服务器或数据库管理系统，它永远不会退出），泄露内存就是很大的问题，最终会导致应用程序在内存不足时崩溃。</p>
<ol>
<li><strong>如何查看端口占用</strong></li>
</ol>
<p>netstat</p>
<ol>
<li><strong>查看进程内存与CPU占用情况</strong></li>
</ol>
<p>top</p>
<ol>
<li><strong>内存溢出的产生原因与相关处理</strong></li>
</ol>
<p>没有分配足够的内存，有时称为缓冲区溢出。</p>
<p>在某些情况下，这是无害的，可能会覆盖不再使用的变量。在某些情况下，这些溢出可 能具有令人难以置信的危害，实实上是系统中许多安全漏洞的来源。在其他情况下， malloc 库总是分配一些额外的空间，因此你的程序实实上不会在其他某个变量的值上涂写， 并且工作得很好。还有一些情况下，该程序确实会发生故障和崩溃。</p>
<ol>
<li><strong>操作系统分页、分段、TLB</strong></li>
</ol>
<p>操作系统需要把进程的地址空间映射到物理内存，如果完全照搬，将会有大量的空间浪费。具体怎么映射，就有了分段、分页。</p>
<p>分段：需要多对基址、界限寄存器。会有外部碎片</p>
<p>分页：将地址空间划分为固定的大小。需要额外的一次内存访问。</p>
<p>TLB：用来解决分页中额外的一次内存访问</p>
<p><strong>页表太大</strong></p>
<ul>
<li>段页式</li>
<li>多级页表：与使用的地址空间成比例，更紧凑</li>
</ul>
<p>请求分页、请求分段：在硬盘上开辟一片空间用于物理页的移入和移出：交换空间。书P166</p>
<blockquote>
<p>正在运行的进程生成虚拟内存引用（用于获取指令 或访问数据），在这种情况下，硬件将其转换为物理地址，再从内存中获取所需数据。 硬件首先从虚拟地址获得 VPN，检查 TLB 是否匹配（TLB 命中），如果命中，则获得最终的物理地址并从内存中取回。这希望是常见情形，因为它很快（不需要额外的内存访问）。 如果在 TLB 中找不到 VPN（即 TLB 未命中），则硬件在内存中查找页表（使用页表基 址寄存器），并使用 VPN 查找该页的页表项（PTE）作为索引。如果页有效且存在于物理内存中，则硬件从 PTE 中获得 PFN，将其插入 TLB，并重试该指令，这次产生 TLB 命中。到现在为止还挺好。 但是，如果希望允许页交换到硬盘，必须添加更多的机制。具体来说，当硬件在 PTE 中查找时，可能发现页不在物理内存中。硬件（或操作系统，在软件管理 TLB 时）判断是否在内存中的方法，是通过页表项中的一条新信息，即存在位（present bit）。如果存在位设 置为 1，则表示该页存在于物理内存中，并且所有内容都如上所述进行。如果存在位设置为 零，则页不在内存中，而在硬盘上。访问不在物理内存中的页，这种行为通常被称为页错 误（page fault）。</p>
<p>如果一个页不存在，它已被交换到硬盘，在处理页错误的时候，操作系统需要将该页 交换到内存中。那么，问题来了：操作系统如何知道所需的页在哪儿？在许多系统中，页 表是存储这些信息最自然的地方。因此，操作系统可以用 PTE 中的某些位来存储硬盘地址， 这些位通常用来存储像页的 PFN 这样的数据。当操作系统接收到页错误时，它会在 PTE 中 查找地址，并将请求发送到硬盘，将页读取到内存中。</p>
</blockquote>
<ol>
<li>页面置换算法</li>
</ol>
<ul>
<li>最优替换策略：只用来做对比</li>
<li>先入先出</li>
<li>随机</li>
<li>LRU、LFU：P180，完美LRU实现代价较高</li>
<li>时钟算法：近似LRU</li>
</ul>
<ol>
<li>用户态如何切换到内核态</li>
</ol>
<p>每个进程都有一个内核栈，用来保存进程的上下文。P40</p>
<p><strong>进程切换的具体过程</strong>：P43，上下文的保存/恢复有两种。</p>
<ol>
<li><em>epoll底层原理*</em>：看cyc</li>
<li><strong>简述信号量机制</strong></li>
</ol>
<p>编写并发程序的强大而灵活的原语</p>
<ol>
<li>并发与并行的区别</li>
</ol>
<p>并发：一段时间</p>
<p>并行：同时</p>
<ol>
<li><p>系统调用的全过程：参考17</p>
</li>
<li><p>僵尸进程、孤儿进程</p>
</li>
</ol>
<p>孤儿进程</p>
<p>如果父进程先退出，子进程还没退出，那么子进程的父进程将变为init进程。（注：任何一个进程都必须有父进程）。</p>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>
<p>僵尸进程</p>
<p>如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。</p>
<p>设置<strong>僵尸进程的目</strong>的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵尸状态）。</p>
<ol>
<li>进程、线程切换的差别</li>
</ol>
<p>线程上下文切换类似于进程上下文切换，进程切换将状态保存到进程控制块（PCB），线程对应线程控制    块（TCB）。线程切换地址空间不变，不需要切换当前使用的页表。</p>
<ol>
<li>kill与kill -9的区别</li>
</ol>
<p>默认情况下<code>kill</code>命令的参数为-15， 代表的信号为<code>SIGTERM</code>，这是告诉进程你<strong>需要被关闭，请自行停止运行并退出</strong>；</p>
<p>而<code>kill -9</code>代表的信号是<code>SIGKILL</code>，表示进程被终止，需要<strong>立即退出</strong>；</p>
<p>因此<code>kill -9</code>表示强制杀死该进程，这个信号<strong>不能被捕获也不能被忽略</strong>。</p>
<ol>
<li>内存分配算法</li>
</ol>
<ul>
<li>最优匹配：遍历查找，性能较差。产生很多难以利用的小块</li>
<li>最差匹配：需要遍历、导致过量的碎片</li>
<li>首次匹配：速度优势、空闲块按内存地址排序</li>
<li>下次匹配：维护一个指针，指向上一个查找结束的位置，查找操作扩散到整个列表中去。</li>
</ul>
<ol>
<li>零拷贝原理</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>新冠日记</title>
    <url>/posts/44ed0285.html</url>
    <content><![CDATA[<p>几个月来，新冠的各种信息一直充斥在网络上和生活周围，但我总觉得不会落到自己身上，直到岁末</p>
<p>11月29号学校出了阳性，当天学校就出了赶人的意思，申请了12月1日离校。回到家居家一周，一切照常。12月9号同学四人去了同学家吃饭，第二天有一个同学发烧了，抗原测了阳性，当时我还没什么感觉，幼稚地以为没那么容易感染。11日晚，嗓子有点不舒服也有点发热，感觉不妙<span class="github-emoji" alias="sleepy" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62a.png?v8">&#x1f62a;</span>。我们三个同时出了症状，看来是有个潜伏期</p>
<p><strong>12月12日</strong></p>
<p>自己感觉低烧，其实是因为我的手本来就比正常温度高，摸着额头好像只是低烧。上午大概是38.7，没敢和家里人说是前两天吃饭传上的，要被骂死哈哈。10号的时候姐姐一家过来吃饭，后面到了20号多他们也阳了，应该不是我传上的，可能10号的时候我还没多少传染性。下午就39度多了，吃了布洛芬和莲花清瘟。但是当天还不算太难受，只是头晕，还能玩原神<span class="github-emoji" alias="dog" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8">&#x1f436;</span></p>
<p><strong>12月13日</strong></p>
<p>凌晨开始，头疼地无法入睡。12点半醒了，试图通过捂被子出汗来降温，但根本没效果，越捂越热几近爆炸。3点多，群里又聊了起来，大家都难受地不能入睡。体温40.4，给我烧迷糊了，找了个毛巾裹脑袋上降温，身上不能盖被，哪盖着被哪就巨快升温，只能稍微盖着点肚子。就这么混沌地熬到了六点，大概没有那么难受了，能正常盖被了，渐渐睡去</p>
<p>又似乎出现了小时候的那种感觉。小的时候，发烧时经常能看到一些类似蓝色血管的原始森林，很多血管在急速地变大变小，长大后不再出现。这次是会看到很多不同种类的形状，每次翻身都会打乱。到早上有所恢复后，每次翻身和盖被子都能把它们组合出一个规则形状。肯定是被那些微分几何、矢量化什么的pua所致，什么垃圾方向</p>
<p>这两天突然地想到了这首歌，在头脑混乱时让人有温吞振奋之感：</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=17120804&auto=0&height=66"></iframe>

<p>整个白天体温都在39度多，头疼异常，吃了莲花清瘟不起作用。基本上是一觉接着一觉，到了晚上七点多睡醒，体温38度多，出了些汗没那么难受了，和前一天差不多</p>
<p><strong>12月14日</strong></p>
<p>凌晨三点多醒了，明显感觉体温降了下来，一量36.7。正是阿根廷克罗地亚踢比赛的时候，想着支持莫德里奇，不过比分2 : 0了，遂睡去</p>
<p>当天正常，那几天嘴里发苦，吃什么都感觉有点咸，不知是新冠的原因还是饭菜确实做咸了。有点咳痰，不过就那一会，记不清是不是这一天了</p>
<p><strong>12月15日</strong></p>
<p>下午体温又升到38度多，头疼到晚上</p>
<p><strong>12月16日</strong></p>
<p>不难受了，体温好像是37度多，之后没再怎么量过</p>
<hr>
<p>之后的几天有点咳嗽，可能是胸闷气短吧。家里没抗原一直没测，21号拿到抗原测了转阴</p>
<p>一直到月底，多少有一点点气短的感觉，就先不运动了(其实本来也不运动<span class="github-emoji" alias="dog" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8">&#x1f436;</span>)，恢复一个月看看</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>新冠</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业前后</title>
    <url>/posts/812f5981.html</url>
    <content><![CDATA[<center>     <img src="https://huangsl-1304681817.cos.ap-beijing.myqcloud.com/img/IMG_20230705_170612.jpg" width=48%>     <img src="https://huangsl-1304681817.cos.ap-beijing.myqcloud.com/img/IMG_20230705_171121.jpg" width=48%> </center>

<p>学校那条由南向北的路很短，也终于走到了最后。再见，我的学生时代</p>
<p>一年前的今天，我应该躺在刚租好的屋子里。双榆树东里，“双榆树”是一个很美好的词语，它变成了某种隐喻。如果春天路过那里，树木一定很是让人欣喜</p>
<p>一年过去了，我有什么变化吗？没有，这几年几乎没有转变过什么。未来的种种可能性铺展在眼前，我感到一丝非理性的迷信，总是觉得自己就要触碰到理想的生活了</p>
<p>一个月前收到了中行软开的签约通知，这对我再好不过了，银行稳定且工作强度没那么大，我可以把更多精力放在工作之外。匆匆而过的五个月，没有留下什么</p>
<p>二月初回到学校，开始写毕业论文。从零开始，又编又抄，偶尔应付下老师的无聊任务。构想创新点的过程十分不可复现，四处找文献，好在找到了一个说得过去的，将近一个月把初稿写完。系统上面没有花太多时间，拿现成的改了改。3月17交初稿，四月份没有抽到盲审和预答辩，5月31最后答辩，还算顺利</p>
<p>三月份开始考虑春招了，心里不太想准备，重新找工作的过程很厌烦，去字节也没什么不好，相信自己是能在互联网立足的。投了十来家，基本都是银行，四五月份做了很多笔试，也面了不少次。日子随着睡觉时的翻身不断流走，只在回忆时才发觉漫长。这段时间除非有事，都会躺到中午才下床，这种生活当然很不错。五月底字节HR打来电话，问什么时候入职，只好说七月初。在毕业论文签完字后，心想下一周要开始学习了，几个月不写代码什么都忘了，就在那几天收到了中行的签约，自己好像总能在最后时刻改写比分</p>
<p>在公司附近租了房，一言难尽但就这么住着吧。前几年工资不高但涨幅还可以，先攒攒房租和看牙的钱，可以更多地来说说毕业之后的事了</p>
<p>五一之前买了些素描用的纸笔工具，到现在还没拆封，等回到住的地方就开始每天学一点吧。这事在二零年初干过一次，不过画了几次就放弃了，直线都画不直。后面再买个midi键盘，乐理也要学一学。书准备了一些，小说有《托尔斯泰中短篇小说选》《地下室手记》《玩笑》，也准备看看康德的《未来形而上学导论》、再了解下黑格尔的思想，其实阅读倾向很明显，读大家的简短、概括的入门作品，很多想读的存在主义著作也是从批判黑格尔出发的，尽力去阅读吧。还有像《叶嘉莹说汉魏六朝诗》、《日常生活的心理分析》等书，当然还在平板上下了很多漫画，漫画似乎是连结当下与小时候的最快通路了。继续网上冲浪！音乐、电影也别落下</p>
<p>在编程上也更待提高，要加强基本功。面对工作上的屎山代码、复杂业务逻辑，确实没什么乐趣可言，但自己写点什么就很有意思了。先把《深入理解计算机系统》、《计算机程序的构造和解释》看了，相应的实验也尽力去写，争取把那几个经典课程的实验都做了。另一条是开发路线，开始先再熟悉下Java的开发过程，后面学学别的，elixir很有吸引力，PHP和Ruby也可以考虑，前端客户端桌面端就用flutter，不过也可以学学pyqt，对前端那一套深恶痛绝，npm不可能再碰了。做点开源的东西，多更新博客</p>
<p>现在的文字多是流水账，阅读太少写得也少，未来要持续地阅读、写作。还有些别的想说，留到下次吧</p>
<p>School‘s out，what did you expect？</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=18295909&auto=0&height=66"></iframe>]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>秋招总结</title>
    <url>/posts/52dbc020.html</url>
    <content><![CDATA[<p>磨蹭到年底才动笔，秋招大概进行了两个半月，一共投递了80多家，互联网外企国企银行都投了，听说过的没听说过的都有。最后拿到了农行、滴滴、字节、分贝通、渤海银行的offer，决定去字节了。感觉选什么都会后悔，就不多想了。谁知道当下的选择会对未来有什么影响呢，那些其他选择的分叉道路会更好吗？</p>
<p>也稍微提提实习，大概从寒假就准备找实习，一直到四月底才投出简历，七月初拿到了字节的实习。读了研以来走了不少弯路，不论科研还是找工作都有，这些也很难避免。很长时间在原地踏步，花费了很多时间技术上并没有什么提升</p>
<p>七月份刚去的时候，mentor跟我说小组里还有一个名额，到八月份的时候说让我两手准备。我也有心理预期，上半年来就有各种毁意向、毁offer、裁员的消息。实习到8月底，这两个月的实习还是收获很大的，虽然没干多少活，主要是熟悉了实际的开发流程，包括需求对接、开发调试、测试上线等等。部门里的同事都很好，工作氛围也不错，没能转正真的很可惜</p>
<p>九月一号回到学校，全力准备秋招。八月下旬投了几家，微软、亚马逊、华为、美团等，做了几个笔试。九月份主要面了美团、网易、京东、华为</p>
<p><strong>美团</strong>：面了地图和配送部门，两个都是一面挂了，八股项目加做题，答得还凑合，可能还是比不过其他面试同学</p>
<p><strong>网易</strong>：传媒事业群，大概负责网易新闻、网易公开课这一块。面得一般，一面问了一道很大的系统设计题：如何设计微信朋友圈，之前没准备过，胡言乱语一通，面试官人很好，一直在很认真地和我沟通；二面答得很差，一道二分的题没做好，跟面试官battle了十多分钟，后来发现还是我做错了<span class="github-emoji" alias="sob" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8">&#x1f62d;</span>。面试官说我的简历没什么可问的，也确实，不少东西写简历上了但我没准备，问了我也没答上来，十分减分，比如Kitex。11月份才给挂了，网易是真的磨叽</p>
<p><strong>京东</strong>：京东科技，主要是负责消费券、智慧城市什么的。一面问了半个小时，没有做题，主要问的八股，答得还行；二面几乎什么都没问匆匆结束；HR面随便问了问。10月底挂了</p>
<p><strong>华为</strong>：公共开发部，九月底的几天一面二面主管面。一面二面正常地问了问，主管面有点像HR面，大概聊了半个小时。一直到写下本文的年底，都没有消息，不过自己很早就不抱希望了</p>
<p>九月份还面了集度、龙湖、友塔游戏。集度一面挂，十月份集度给同学开得挺高；龙湖没太放在心上，十一月初好像才全部面完；友塔十月份挂了。重点提一下阿里，那段时间面了几次阿里，都是电话面然后秒挂，有天猫精灵和钉钉，会问一些八股和设计题，应该就是要求高，面试体验比较差</p>
<p>整个九月份都在笔试、面试中度过，忙碌中没有时间想什么。国庆的时候还是很有信心，京东网易华为我总能拿一个吧，后来才慢慢明白，对一些事没必要有过高期待。国庆躺了一周</p>
<p>十月份整体是越来越绝望的状态，面试越来越少，一个月没面几家：滴滴友塔荣耀，只有滴滴走完了流程。到十月下旬，基本对互联网不抱希望了，之前在截止日期之前投了不少银行，十月底银行扎堆笔试，那两天累死。那段时间没有面试，也没什么要学的，基本每天只是躺着，丧到了极点。那些天又重新开始玩饥荒了，算是苦中作乐</p>
<p><strong>滴滴</strong>：国际化部门，负责南美的打车外卖业务。12号一面二面，13号三面。一面正常的八股加做题，不过出了道最大矩形的hard题，憋了半天做出来了。紧接着二面，问了一些实际开发中的问题，没答太好，做的题类似于排行榜的设计题，对Redis还是了解不够。三面也是正常问了问，这次直接问了如何设计微博的点赞排行榜，两面在同一个点被薄纱<span class="github-emoji" alias="sob" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8">&#x1f62d;</span>.11月17号电话给了意向，开得有点低，后面拒了</p>
<p><strong>银行</strong>：10月21面了渤海银行，基础的八股，不过很多都没答好；11月10号那块问了boss上的渤海HR，她说过了在审批中，这才算是有了秋招的第一个意向，终于喘过来一口气；12月初才发体检通知，没再考虑。11月9号面了农行天研，面试问得很广，答得更差；11月15发了体检通知，很是高兴，这两个算是天津最好的开发岗位了；18号去做了体检，不过心率有点问题要求复检，被封在学校加上接了字节的offer，遗憾拒了</p>
<p>11月初，又赶上一波互联网的补录，面了快手、蚂蚁、字节、分贝通、完美世界和京东，不过都是相对边缘一些的部门了，不过无所谓，整整两个月没一个offer，有面试就还有希望。写到这有点累了，不再展开写了，快手二面挂；蚂蚁和阿里类似一面挂；分贝通走完了流程，面试官人很好，面完的下一周收到了意向，offer给得比较晚拒了，不过十分感谢豪哥内推；完美世界一面挂，其实答得挺好</p>
<p><strong>字节</strong>：10月份面了TikTok直播，一面挂，答得一般；比较奇怪的是，在网站上更新的简历面试官一直看不到，实习那一块没加上。11月1号有HR打电话说之前的面试挂了，又转到了其他部门。4号一面，八股加做题，感觉答得一般；8号二面，答得还可以，题比较顺利；11号三面，答得也还行，那段时间又多看了看Redis，关于怎么设计排行榜和集群的知识，不过题做得有点磕磕绊绊，是这道<a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a>的hard题；14号通知四面，还是技术面，一般应该是HR面了，以为凉了，再面一轮是要继续刷人吗；16号四面问了一点设计题，问了一些实习的经历，最后简单做了一道题，最后还问了“你遇到的最大困难是什么”，也有点像HR面了，面试官是上海的，我以为给转到了上海的部门；之后两天HR打了两个电话，问了之前实习的部门、为什么实习时间这么短、意向工作地点、能不能提前去实习等；21号发了offer，流程很快，base北京、给的也很满意了，同天上午农行的老师跟我说要复检心电图，不能出学校短时间复检不了，这算是机缘巧合吗(不太合适这个词)? 接了字节的offer，没想太多，当然也想不出来什么</p>
<p>之后的面试都没参加了。月底学校疫情严重了，30号临走之前和同学寄了三方，秋招也彻底结束。回到家后，又收到了美团、京东、阿里的面试通知，没再继续。12月初得知字节盘点HC，大概11月下旬开始的，很多人的面试流程暂停了，我可能赶上了最后一波，又在脉脉上看到字节毁意向、开劝退价的帖子。很多时候我们在抱怨当前处境的时候，不知道的是，其实能走到现在已经足够得幸运。再提一句，少看脉脉！我面试的部门信息很少，在脉脉上能搜到的评价就那几条，都在疯狂劝退，我又能做什么，很累不想再去准备面试了，希望自己不会试用期被裁</p>
<p>专注当下，继续坚持，未来会走到何处？无所谓，都没关系︿(￣︶￣)︿</p>
]]></content>
      <tags>
        <tag>秋招</tag>
      </tags>
  </entry>
</search>
